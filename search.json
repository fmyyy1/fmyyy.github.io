[{"title":"2021第五空间webakwp","date":"2021-09-21T14:10:04.000Z","url":"/2021/09/21/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4webakwp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言挺傻逼的，5道web题全是静态靶机，三道rce题，不知道主办方咋想的。附一张图不过也算是ak了web 总体感觉还不错 webftp这题就要说到搅屎的问题了，我直接扫路径扫到1.txt看到flag，大概是哪位大师傅放的赛后跟别的师傅聊了一下，预期解是github上能下载源码然后看就行。 EasyCleanup源码逻辑很简单，给了phpinfo和任意文件包含这里的 session.upload_progress.cleanup 是off的，不会自动清除session文件那直接传PHPSESSID然后包含就行,都不需要条件竞争。exp 然后包含/tmp/sess_aa传命令即可 pklovecloud简单的反序列化poc 之后源码找flag PNG图片转换器这里利用了ruby的open函数能造成命令执行的特性open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 管道字符“|”开头，执行管道字符后面的命令 原题传文件，获得唯一文件名，然后读取文件的base64编码。在读取这里 file可控，但得满足上面的条件，这个限制也不是很严格上传两张图片记住文件名在/convernt处第一步file=|echo &quot;Y2F0IC8q&quot;|base64 -d &gt; 0784368baeb4d0a58b04309f20df6f2e.pngY2F0IC8q是cat /*的base64第二步file=|sh 0784368baeb4d0a58b04309f20df6f2e.png&gt;405391431ca1ac9b33f35add1f4ef55c.png之后读405391431ca1ac9b33f35add1f4ef55c.png拿到flag base64解码即可 补充赛后跟feng师傅聊了一下 发现不用这么麻烦，在上传处即可命令执行可以看到，加密的参数是file[filename]但open的参数file[tempfile]是可控的 所以直接再读这个文件即可 yet_another_mysql_injection能时间盲注，但数据库里啥也没有再看逻辑， 就是查询语句要和查询结果一样就可以了这篇文章很详细原文的payload改一下能用原文的SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;) AS Quine本题有过滤，且是注入，所以得改一下 更改后的：username=admin&amp;password=&#39;UNION/**/SELECT/**/REPLACE(REPLACE(&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;,CHAR(34),CHAR(39)),CHAR(63),&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;)/**/AS/**/a#直接打就行 总结企业组第十三，，akweb的队伍很多，主要还是靠队友的misc re和密码才拿到这个名次，又被队友带飞了"},{"title":"2021祥云杯web部分wp","date":"2021-09-21T13:14:04.000Z","url":"/2021/09/21/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E4%B8%AA%E4%BA%BAweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言体验还行 ezyii说是最新的链子，题目把文件都筛选好了让我们找。写一下我的思路看到RunProcess类 底下有个字符串拼接，可以触发__toString,全局搜索__toString AppendStream下有__toString 并且调用了rewind(),找找看这个rewindCachingStream类这里有，并且还调用了seek方法，seek又调用了read方法,在这个read方法里又调用了一个read方法 我们可以控制$this-&gt;stream为我们想要的类，查找read，最后在PumpStream类里 这个类有read方法 ，read调用了pump pump方法调用了call_user_func，所以可以RCE 就写到这吧 我把链子找完的时候队友已经出了，还告诉我网上有公开的poc，心累，说好的最新呢 安全检测检测127.0.0.1成功了 是ssrf，利用ssrf扫路径扫到了源码 包含一下session文件呗payload: 你的PHPSESSID&amp;payload=成功了 挺奇怪的 源码里ban了反引号我这里却可以用 不管了 flag出了就行。 层层穿透这题做了好久，只会一点java的我靠着github上的一键shell poc做完了第一层反弹shell，github有直接可以利用的工具 弹个shell到自己的公网上。题目提示内网信息搜集到了10.10.1.11:8080,估计是内网web环境，先把附件源码反编译一下，因为题目环境20分钟刷新一次，所以现在本地打对着源码逻辑先登录，账号密码源码里可以直接找到 看到admin/test路由存在fastjson反序列化点。不怎么会java反序列化，但是github上有不出网直接在数据包里回显的一键shellpoc照着github上的readme直接打，发现提示太短，看源码把poc复制两边再打就打通了本地打通了，之后是题目。我花了大部分时间在搞代理 有几个小时吧 最后选择了frp 确实方便frp教程端口转发成功后按照刚刚本地的步骤直接打就行（一定找个时间好好学java） Crawer_z引用了zombie框架，谷歌查找 全网只找到这个框架一篇漏洞漏洞描述攻击者可以在他们的页面中插入JS代码来利用zombiejs代码注入漏洞。如果使用zombiejs 抓取此类页面，则运行爬虫的机器将运行攻击者提供的任意命令。为了比较，jsdom 默认禁用脚本执行。 想办法让题目访问我们准备的恶意页面就行。payload在这个博客里都准备好了，提取一下 改成弹shell的 有了payload，我们要想办法让题目访问我们的恶意页面。看一下源码。在user.js下看到访问/user/bucket似乎会自动访问我们个人信息里设置的bucket，尝试访问。尝试更改bucket设置，先看源码在checkBucket函数下，看到bucket的要求，必须以http:或者https:为开头，且必须包含oss-cn-beijing.ichunqiu.com我们尝试修改前面为自己的公网ip地址点击更新 变回原来的了，并且提示admin会来检查，但在源码里看到这里其实算是更改失败了，admin不会去检查源码里有个重定向到/user/verify?token=${authToken}，我们尝试用队伍token浏览器url输入队伍token修改bucket，但不要点击update，直接在访问我们放入队伍token后的url提示更改成功 看到我们的bucket也被设置成了我们的服务器地址其实这里我还没怎么懂原理，只是试了一下发现可以，那就歪打正着直接用。再访问/user/bucket回显的内容变了，报错404，这是因为我的公网上没有oss-cn-beijing.ichunqiu.com这个文件。到这里思路就很清晰了，我们在公网上放置一个oss-cn-beijing.ichunqiu.com.html恶意文件，然后修改bucket为http://公网ip地址/oss-cn-beijing.ichunqiu.com.html并且这个html文件已经被我们插入了用&lt;script&gt;标签包裹的恶意payload服务器起个监听题目内访问/user/bucket弹成功了。 这次比赛就做了这四道题，做完java那题距比赛结束就1小时了，被队友带飞进了前三十 队友们tql"},{"title":"java反射学习-3","date":"2021-08-29T13:14:04.000Z","url":"/2021/08/29/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-3/","categories":[["java","/categories/java/"]],"content":"解决两个问题1.如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？2.如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题这里要引入新的反射方法 getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数： 比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令： 上面用到了第一个形式的构造函数，所以我在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表 达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。其实用的就是前面讲过的知识： 通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反 射执行呢？ 这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）： 那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。 所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 第二个问题这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：1.getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法2.getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了举个例子，前文我们说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令： "},{"title":"java反射学习-2","date":"2021-08-26T13:14:04.000Z","url":"/2021/08/26/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-2/","categories":[["java","/categories/java/"]],"content":"上一篇学完了反射的基础，接下来深入学习一下。 在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不 需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类 同时，forName()还可以获取内部类 我们通过forName获得类之后用newInstance()来调用这个类的无参构造函数，但有时这个方法会失败，原因可能是： 你使用的类没有无参构造函数 你使用的类构造函数是私有的常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令： 因为Runtime类的构造方法是私有的。但还是有方法获取到这个类的，这涉及到单例模式。比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连 接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来 获取： 之后获取这个类的方法为getInstance。Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对 象。我们将上述Payload进行修改即可正常执行命令了： Runtime.exec有6个重载，第一个重载，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。invoke 的作用是执行方法，它的第一个参数是：1.如果这个方法是一个普通方法，那么第一个参数是类对象2.如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 所以我们将上述命令执行的Payload分解一下就是： "},{"title":"java反射学习-1","date":"2021-08-25T13:14:04.000Z","url":"/2021/08/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-1/","categories":[["java","/categories/java/"]],"content":"学习java反序列化之前少不了学习反射，虽然之前学过，还是再学一遍 java反射机制的定义Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java的反序列化问题都基于反射机制 Java 反射机制的功能1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法。5.生成动态代理。 Java 反射机制的应用场景1.逆向代码 ，例如反编译2.与注解相结合的框架 例如Retrofit3.单纯的反射机制应用框架 例如EventBus4.动态生成类框架 例如Gson 反射常见使用的方法获取类的方法：forname实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 只有JVM能够创建Class对象 获取class对象三种方法一般我们获取class对象就有以下三种方法 1、类的.class属性第一种就是最简单明了的方式，我们可以通过类名的属性class获取。 2、实例化对象的getClass()方法第二种我们可以先实例化一个对象，之后在调用getClass()方法。 3、Class.forName(String className)：动态加载类第三种则是调用Class类中的forName方法，将字节码文件加载进内存，返回Class对象。 总的来看 结果 但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 获取成员变量Field 获取成员方法Method 获取构造函数 利用反射创建类对象（重点）在前面我们获取了Class对象，之后展示了一系列获取成员变量、成员方法和成员函数的方式后，我们现在可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象。 使用的方式也特别简单，只需要通过forname方法获取到的class对象中进行newInstance方法创建即可。 利用反射机制创建类并执行方法"}]