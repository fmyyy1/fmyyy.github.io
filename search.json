[{"title":"2021第五空间webakwp","date":"2021-09-21T14:10:04.000Z","url":"/2021/09/21/2021%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4webakwp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言挺傻逼的，5道web题全是静态靶机，三道rce题，不知道主办方咋想的。附一张图不过也算是ak了web 总体感觉还不错 webftp这题就要说到搅屎的问题了，我直接扫路径扫到1.txt看到flag，大概是哪位大师傅放的赛后跟别的师傅聊了一下，预期解是github上能下载源码然后看就行。 EasyCleanup源码逻辑很简单，给了phpinfo和任意文件包含这里的 session.upload_progress.cleanup 是off的，不会自动清除session文件那直接传PHPSESSID然后包含就行,都不需要条件竞争。exp 然后包含/tmp/sess_aa传命令即可 pklovecloud简单的反序列化poc 之后源码找flag PNG图片转换器这里利用了ruby的open函数能造成命令执行的特性open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 管道字符“|”开头，执行管道字符后面的命令 原题传文件，获得唯一文件名，然后读取文件的base64编码。在读取这里 file可控，但得满足上面的条件，这个限制也不是很严格上传两张图片记住文件名在/convernt处第一步file=|echo &quot;Y2F0IC8q&quot;|base64 -d &gt; 0784368baeb4d0a58b04309f20df6f2e.pngY2F0IC8q是cat /*的base64第二步file=|sh 0784368baeb4d0a58b04309f20df6f2e.png&gt;405391431ca1ac9b33f35add1f4ef55c.png之后读405391431ca1ac9b33f35add1f4ef55c.png拿到flag base64解码即可 补充赛后跟feng师傅聊了一下 发现不用这么麻烦，在上传处即可命令执行可以看到，加密的参数是file[filename]但open的参数file[tempfile]是可控的 所以直接再读这个文件即可 yet_another_mysql_injection能时间盲注，但数据库里啥也没有再看逻辑， 就是查询语句要和查询结果一样就可以了这篇文章很详细原文的payload改一下能用原文的SELECT REPLACE(REPLACE(&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;,CHAR(34),CHAR(39)),CHAR(36),&#39;SELECT REPLACE(REPLACE(&quot;$&quot;,CHAR(34),CHAR(39)),CHAR(36),&quot;$&quot;) AS Quine&#39;) AS Quine本题有过滤，且是注入，所以得改一下 更改后的：username=admin&amp;password=&#39;UNION/**/SELECT/**/REPLACE(REPLACE(&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;,CHAR(34),CHAR(39)),CHAR(63),&#39;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHAR(34),CHAR(39)),CHAR(63),&quot;?&quot;)/**/AS/**/a#&#39;)/**/AS/**/a#直接打就行 总结企业组第十三，，akweb的队伍很多，主要还是靠队友的misc re和密码才拿到这个名次，又被队友带飞了"},{"title":"2021祥云杯web部分wp","date":"2021-09-21T13:14:04.000Z","url":"/2021/09/21/2021%E7%A5%A5%E4%BA%91%E6%9D%AF%E4%B8%AA%E4%BA%BAweb%E9%83%A8%E5%88%86wp/","categories":[["CTFwp","/categories/CTFwp/"]],"content":"前言体验还行 ezyii说是最新的链子，题目把文件都筛选好了让我们找。写一下我的思路看到RunProcess类 底下有个字符串拼接，可以触发__toString,全局搜索__toString AppendStream下有__toString 并且调用了rewind(),找找看这个rewindCachingStream类这里有，并且还调用了seek方法，seek又调用了read方法,在这个read方法里又调用了一个read方法 我们可以控制$this-&gt;stream为我们想要的类，查找read，最后在PumpStream类里 这个类有read方法 ，read调用了pump pump方法调用了call_user_func，所以可以RCE 就写到这吧 我把链子找完的时候队友已经出了，还告诉我网上有公开的poc，心累，说好的最新呢 安全检测检测127.0.0.1成功了 是ssrf，利用ssrf扫路径扫到了源码 包含一下session文件呗payload: 你的PHPSESSID&amp;payload=成功了 挺奇怪的 源码里ban了反引号我这里却可以用 不管了 flag出了就行。 层层穿透这题做了好久，只会一点java的我靠着github上的一键shell poc做完了第一层反弹shell，github有直接可以利用的工具 弹个shell到自己的公网上。题目提示内网信息搜集到了10.10.1.11:8080,估计是内网web环境，先把附件源码反编译一下，因为题目环境20分钟刷新一次，所以现在本地打对着源码逻辑先登录，账号密码源码里可以直接找到 看到admin/test路由存在fastjson反序列化点。不怎么会java反序列化，但是github上有不出网直接在数据包里回显的一键shellpoc照着github上的readme直接打，发现提示太短，看源码把poc复制两边再打就打通了本地打通了，之后是题目。我花了大部分时间在搞代理 有几个小时吧 最后选择了frp 确实方便frp教程端口转发成功后按照刚刚本地的步骤直接打就行（一定找个时间好好学java） Crawer_z引用了zombie框架，谷歌查找 全网只找到这个框架一篇漏洞漏洞描述攻击者可以在他们的页面中插入JS代码来利用zombiejs代码注入漏洞。如果使用zombiejs 抓取此类页面，则运行爬虫的机器将运行攻击者提供的任意命令。为了比较，jsdom 默认禁用脚本执行。 想办法让题目访问我们准备的恶意页面就行。payload在这个博客里都准备好了，提取一下 改成弹shell的 有了payload，我们要想办法让题目访问我们的恶意页面。看一下源码。在user.js下看到访问/user/bucket似乎会自动访问我们个人信息里设置的bucket，尝试访问。尝试更改bucket设置，先看源码在checkBucket函数下，看到bucket的要求，必须以http:或者https:为开头，且必须包含oss-cn-beijing.ichunqiu.com我们尝试修改前面为自己的公网ip地址点击更新 变回原来的了，并且提示admin会来检查，但在源码里看到这里其实算是更改失败了，admin不会去检查源码里有个重定向到/user/verify?token=${authToken}，我们尝试用队伍token浏览器url输入队伍token修改bucket，但不要点击update，直接在访问我们放入队伍token后的url提示更改成功 看到我们的bucket也被设置成了我们的服务器地址其实这里我还没怎么懂原理，只是试了一下发现可以，那就歪打正着直接用。再访问/user/bucket回显的内容变了，报错404，这是因为我的公网上没有oss-cn-beijing.ichunqiu.com这个文件。到这里思路就很清晰了，我们在公网上放置一个oss-cn-beijing.ichunqiu.com.html恶意文件，然后修改bucket为http://公网ip地址/oss-cn-beijing.ichunqiu.com.html并且这个html文件已经被我们插入了用&lt;script&gt;标签包裹的恶意payload服务器起个监听题目内访问/user/bucket弹成功了。 这次比赛就做了这四道题，做完java那题距比赛结束就1小时了，被队友带飞进了前三十 队友们tql"},{"title":"一条laravel5.1的链子","date":"2021-09-10T13:14:04.000Z","url":"/2021/09/10/%E4%B8%80%E6%9D%A1laravel5.1%E7%9A%84%E9%93%BE%E5%AD%90/","categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":" ## 前言 挖一整天才挖出这一条，主要是钻牛角尖了，逮着一个地方使劲找链子。 poc先放poc吧 poc分析。我找的destruct方法是Swift_Transport_AbstractSmtpTransport类的看一下他做了什么。调用了该类的stop方法 看一下stop[文件]箭头这里可以触发__call方法，之后找__call就可以了。但这个类是一个抽象类，所以用他的子类Swift_Transport_EsmtpTransport。 之后是找__call方法。我找到的是DatabaseManager类，看一下他的__call方法。调用了该类的connection方法，看一下这个方法。重点在于$this-&gt;makeConnection方法可以看到最下面可以调用任意类的make方法。但其实这里本身就有call_user_func方法，但这里的没办法利用，这个等一下说原因。全局找make方法。最后在FactoryBuilder里该类的make调用了makeInstance再看看makeInstance可以看到call_user_func了，并且参数全可控。所以我们的链子就通了 一些细节 解答一下之前makeConnection方法里的call_user_func为啥不能用。我们看一下他的参数。 第一个参数extensions[$name]是可控的，没有问题，关键是第二个config参数，看一下这个参数是怎么来的。 是该类的getConfig方法来的，看一下这个方法。 return的值是Arr::get方法的返回值，看一下这个方法 可以看到，不管怎么样，返回的都是一个数组。所以这个call_user_func不是很好利用。但应该也有利用的方法，我比较懒就找下面的了。而且正好我们FactoryBuilder里的make方法需要数组作为参数不然就会报错，所以这个config就很好的符合我们的要求但最后的makeInstance方法，因为第三个参数是数组，在执行时会报错。所以时没有回显的，但可以反弹shell或者写文件。我poc里构造的相当于 总结不算很好的链子，利用复杂，构造的参数也很严苛。"},{"title":"java反序列化CC3","date":"2021-09-08T13:14:04.000Z","url":"/2021/09/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC3/","categories":[["java","/categories/java/"]],"content":"学习动态加载字节码的时候学到了TemplatesImpl加载字节码的方法。我们也可以利用这个特性进行命令执行。结合之前CC1的手动加载我们可以写一个简单的demo，这里用p神的 这里同样是手动触发的put，我们尝试利用cc1的TransformedMap链子触发。这里我自己写了个poc 当然LazyMap也是可以通的。 但CC3链子的出现自然有他的道理。CC3产生的目的就是为了绕过⼀些过滤器对InvokerTransformer的限制。越来越多的过滤器将InvokerTransformer类加入了黑名单，CC3链就是为了突破这个限制产生的。在ysoserial的CC3链子中能看到一些新东西。可以看到将InvokerTransformer换成了InstantiateTransformer类。并且引入了一个新的类com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter在这个类的构造函数里面 该构造函数的参数为Templates接口，而且我们之前利用的加载字节码的TemplatesImpl类实现了该接口。构造函数在给__transformer参数赋值的时候进行了类型转换并且调用了newTransformer()方法。这个newTransformer()就是我们利用TemplatesImpl加载字节码的起点。但是没有InvokerTransformer如何调用这个构造方法？这里用到了InstantiateTransformer类 InstantiateTransformerInstantiateTransformer类也是一个实现了Transformer接口的类，看看他的transformer方法做了什么。 这里利用反射的机制调用了构造函数。iArgs参数就是我们的TemplatesImpl类。前面说到我们需要调用TrAXFilter的构造函数才能加载字节码，所以我们能利用这个类来调用TrAXFilter的构造方法就可以加载字节码，到此CC3就通了。poc "},{"title":"java动态加载字节码的方法","date":"2021-09-04T13:14:04.000Z","url":"/2021/09/04/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","categories":[["java","/categories/java/"]],"content":"讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器 TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 讨论方法前先来看看什么是字节码 什么是java字节码严格来说，Java字节码（ByteCode）其实仅仅指的是Java虚拟机执行使用的一类指令，通常被存储在.class文件中。但是我们讨论的字节码可以扩大范围——所有能够恢复成一个类并在JVM虚拟机里加载的字节序列，都在我们的探讨范围内。Java的ClassLoader来用来加载字节码文件最基础的方法 ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的 ClassLoader 就是根据类名来加载类，这个类名是类完整路径，如 java.lang.Runtime 。 方法一、利用URLClassLoader加载远程class文件URLClassLoader是AppClassLoader的父类，该类可以加载远程class文件。正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠 / 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件 URL以斜杠 / 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件 URL以斜杠 / 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类 我们这里要利用第三种，协议得是非file，最常见的就是http先创建一个恶意类 在class文件所在的文件夹下用python快速起一个http服务器之后试试能不能用UrlClassLoader加载这个类 成功弹出计算器所以在实战中，我们如果能控制ClassLoader为一个http服务器就能加载恶意类。 方法二、利用ClassLoader#defineClass直接加载字节码不管是加载远程的class文件还是本地的class文件都是经历下面三个方法调用javaClassLoader#loadClass-&gt;ClassLoader#findClass-&gt;ClassLoader#defineClass loadClass 的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass findClass 的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass defineClass 的作用是处理前面传入的字节码，将其处理成真正的Java类 其核心应该是在defineClass方法，因为这个方法才是最后把字节码转化成真正的java类。我们本地测试一下好了。一个恶意类，弹出计算机 编译成class文件，用shell输出base64编码的字节码之后利用definClass加载 成功弹出计算器 方法三、利用TemplatesImpl加载字节码TemplatesImpl相对于ClassLoader比较底层，但原理是defineClass()在TemplatesImpl内部的静态类TransletClassLoader被重载。 但这个方法是个private方法不能被外部调用，我们继续看看。看到getTransletInstance调用了这个方法，但这仍是个私有方法 继续看最好在NewTransformer方法调用了getTransletInstance，并且这是个public方法，可以外部调用。 调用链是这样的 所以poc就有了，这里放p神的 可以看到poc这里用反射设置了三个参数的值，在源码里可以看到原因_bytecodes是字节码为空的话回返回一个错误_name可以任意赋值，不为空就行 defineTransletClasses()的run方法调用了_tfactory.getExternalExtensionsMap()，_tfactory所以不能为空 值得注意的是， TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类。所以需要构造一个特殊的类来触发。 成功弹出计算器[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ypdjjawo-1632274419328)()]TemplatesImpl似乎在fastjson和jackson出现的比较多，以后会学到。 方法四、利用BCEL ClassLoader加载字节码BCEL也是个大知识点，以后重点学习，这里放一下poc。 "},{"title":"java反序列化CC1-3","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-3/","categories":[["java","/categories/java/"]],"content":" cc1链的最后了。TransformedMap换成了LazyMappoc 核心主要在于LazyMap类的get方法。 如果传入的参数不存在，则调用factory的transform。可以试着写一个非反序列化的命令执行 弹出了计算机（不知道问什么点开就闪退）调试一下看看 可以看到我们get的test这个key是不存在的，所以进入if调用了factory的transform，这个factory就是decorate方法的第二个参数，看源码就知道。[之后的过程就跟之前的TransformedMap链是一样的。 这里是手动执行的get，我们继续研究反序列化的poc。 动态代理sun.reflect.annotation.AnnotationInvocationHandler 的readObject方法中并没有直接调用到Map的get方法。但是AnnotationInvocationHandler类的invoke方法调用了get 调用AnnotationInvocationHandler的invoke方法，这里用到了java对象代理。动态代理详解可以看这篇文章。不过本地调试一下更能理解过程 其实看名字就能看出来AnnotationInvocationHandler实际上就是个InvocationHandler，所以用AnnotationInvocationHandler对我们的map进行代理，这样调用任意方法都会进入AnnotationInvocationHandler.invoke方法进而触发get实现命令执行 总结勉强看完了，但对代理这一块还不是很熟，找个时间自己学一下"},{"title":"java反序列化CC1-2","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-2/","categories":[["java","/categories/java/"]],"content":" 上一篇命令执行是我们手动触发的put方法进行添加新元素，那么真正的反序列化poc呢？看看p神给的poc 不过这个poc我本地算是弹失败了，因为java版本的原因，在Java 8u71以后的版本中，由于 sun.reflect.annotation.AnnotationInvocationHandler 发生了变化导致不再可用。我的版本正好是8u71。不过我来学习思路，也懒的改版本了。 sun.reflect.annotation.AnnotationInvocationHandler触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可 以手工执行 outerMap.put(“test”, “xxxx”); 来触发漏洞，但在实际反序列化时，我们需要找到一个 类，它在反序列化的readObject逻辑里有类似的写入操作。这个类就是 sun.reflect.annotation.AnnotationInvocationHandler源码就不放了，逻辑就是调用了setValue方法，这个方法也能触发TransformedMap里注册的Transform。 关于反射的问题看到前面我们生产Runtime类的时候是直接调用getRuntime方法的[ 但这次的poc不一样，是利用反射调用的 这里涉及到反序列化的条件。1、该类必须直接实现java.io.Serializable接口或者间接从其继承树中实现该接口(也就是他的某个父类实现了这个接口);2、对于该类的所有无法序列化的属性(本文指字段field, 而不是严格意义上的属性property, 下同)必须使用transient修饰。 但Runtime类是没有实现java.io.Serializable接口的，所以不能直接反序列化，但反射能解决这个问题，将 Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。 但是AnnotationInvocationHandler 也不能直接实例化，仍然需要利用反射的机制 总结真累，接下来是CC1的LazyMap，比起TransformedMap似乎LazyMap用的更多"},{"title":"java反序列化CC6","date":"2021-09-02T13:14:04.000Z","url":"/2021/09/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20CC6/","categories":[["java","/categories/java/"]],"content":"因为sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化，导致cc1的链子在8u71版本后无法使用。所以要找一条能在java更高版本使用的链子。 cc6的简化版利用链 p神给的poc CC1是触发LazyMap.get方法进行命令执行，CC6是找到其他调用这个方法的地方。这个类是 org.apache.commons.collections.keyvalue.TiedMapEntry ，在其getValue⽅法中调⽤了 this.map.get ，⽽其hashCode⽅法调⽤了getValue⽅法： 所以又要去找哪里触发了TiedMapEntry.hashCode()。在java.util.HashMap#readObject调用了hashCode该方法最后调用了hash，跟进hash方法看到hash方法调用了hashCode poc里用了个fakeTransformers p神在java安全漫谈反序列化5里讲到了他的作用，主要是为了防止本地调试的时候触发命令执行。 关于poc中的outerMap.remove(“keykey”);去掉outerMap.remove(“keykey”);则无法命令执行，主要原因在expMap.put(tme, “valuevalue”);中expMap是HashMap的实例HashMap.put中也调用了hash，但我们传入的是fakeTransformers，所以对poc产生了一定的影响。 在反序列化的过程中，触发反序列化最重要的LazyMap.get方法中并没有进入if分支里面，所以没有触发transfrom。所以为了让containsKey(key)判断为flase，用outerMap.remove(“keykey”);移除即可。触发transfrom之后的过程就跟cc1时一样的。"},{"title":"java反序列化CC1-1","date":"2021-09-01T13:14:04.000Z","url":"/2021/09/01/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1-1/","categories":[["java","/categories/java/"]],"content":" 最近入门java安全，看一下最基础的CC1链子（URLDNS已经偷偷学过了）先来看看p神原创的最简代码 这里涉及到几个接口和类，一个一个看 Transformer这是个接口，源码也很简单。 看注释，把一个输入的对象输出，这个对象应该保持不变。 TransformedMap及其decorate方法 decorate中 第一个参数为修饰的Map类，第二个参数和第三个参数都是一个实现了Transformer接口的类，转换Map的键和值，为null则不转换。当被修饰的map添加新元素时会分别触发这两个类的transfom方法，也就是说我们之后只要找到能利用的transform方法即可。具体看下面这篇文章里面的一个例子 ConstantTransformer 构造该类时传入一个对象，并在调用transform时返回该对象，算是一种封装。 InvokerTransformer 该类也实现了Transformer类接口的一个类第一个参数是待执行的方法名，第二个参数是函数的参数类型，第三个参数是这个函数的参数列表。重点在改类的transform方法前面说过，通过TransformedMap的decorate方法可以调用任意类的transform方法，所以InvokerTransformer类中的transform及是我们要找的恶意方法，因为他可以导致任意命令执行。 执行原理也很简单，结合之前学过的反射机制很容易就能看懂。 ChainedTransformer 该类也实现了Transformer接口。其构造函数的参数为Transformer[]。主要逻辑算是一种链式调用。将transformers中多个实现Transformer接口的类串在一起，第一个传入的object为第一个类的transform方法的参数，再将执行结果作为transformers列表中下一个类的transform方法的参数。 理解了这些类，再看看p神的构造里的一段。 这里实例化了Transformer[]列表，在下面作为了ChainedTransformer类实例化时的参数。该Transformer[]包含两个Transformer:第一个是ConstantTransformer， 直接返回当前环境的Runtime对象;第二个是InvokerTransformer，获取了exec方法，里面的Object为参数，即exec的参数，这里就是计算器。 总的分析 这里先实例化了一个HashMap类，再用TransformedMap.decorate修饰该类返回了一个新的Map类。前面说过，再被TransformedMap.decorate修饰过的类中添加新元素时会触发第二、第三个参数的transform方法。利用outerMap.put就添加了新元素。下面的这里第二个参数为null，第三个参数为上面实例化的一个ChainedTransformer类。 ChainedTransformer类的transform方法被触发，参数为Transformer[]类。之后利用ChainedTransformer的transform方法链式调用进行命令执行。 总结这算是个半个CC1链子，因为是手动触发的put方法，接下来学完整的CC1链子"},{"title":"java反射学习-3","date":"2021-08-29T13:14:04.000Z","url":"/2021/08/29/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-3/","categories":[["java","/categories/java/"]],"content":"解决两个问题1.如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？2.如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题这里要引入新的反射方法 getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数： 比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令： 上面用到了第一个形式的构造函数，所以我在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，有时候我们利用漏洞的时候（在表 达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。其实用的就是前面讲过的知识： 通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反 射执行呢？ 这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你 定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。 对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价 的（也就不能重载）： 那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。 所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 第二个问题这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：1.getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法2.getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了举个例子，前文我们说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来 获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例 化对象，进而执行命令： "},{"title":"java反射学习-2","date":"2021-08-26T13:14:04.000Z","url":"/2021/08/26/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-2/","categories":[["java","/categories/java/"]],"content":"上一篇学完了反射的基础，接下来深入学习一下。 在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不 需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类 同时，forName()还可以获取内部类 我们通过forName获得类之后用newInstance()来调用这个类的无参构造函数，但有时这个方法会失败，原因可能是： 你使用的类没有无参构造函数 你使用的类构造函数是私有的常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令： 因为Runtime类的构造方法是私有的。但还是有方法获取到这个类的，这涉及到单例模式。比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连 接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来 获取： 之后获取这个类的方法为getInstance。Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对 象。我们将上述Payload进行修改即可正常执行命令了： Runtime.exec有6个重载，第一个重载，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。invoke 的作用是执行方法，它的第一个参数是：1.如果这个方法是一个普通方法，那么第一个参数是类对象2.如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 所以我们将上述命令执行的Payload分解一下就是： "},{"title":"java反射学习-1","date":"2021-08-25T13:14:04.000Z","url":"/2021/08/25/java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0-1/","categories":[["java","/categories/java/"]],"content":"学习java反序列化之前少不了学习反射，虽然之前学过，还是再学一遍 java反射机制的定义Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java的反序列化问题都基于反射机制 Java 反射机制的功能1.在运行时判断任意一个对象所属的类。2.在运行时构造任意一个类的对象。3.在运行时判断任意一个类所具有的成员变量和方法。4.在运行时调用任意一个对象的方法。5.生成动态代理。 Java 反射机制的应用场景1.逆向代码 ，例如反编译2.与注解相结合的框架 例如Retrofit3.单纯的反射机制应用框架 例如EventBus4.动态生成类框架 例如Gson 反射常见使用的方法获取类的方法：forname实例化类对象的方法：newInstance获取函数的方法：getMethod执行函数的方法：invoke 只有JVM能够创建Class对象 获取class对象三种方法一般我们获取class对象就有以下三种方法 1、类的.class属性第一种就是最简单明了的方式，我们可以通过类名的属性class获取。 2、实例化对象的getClass()方法第二种我们可以先实例化一个对象，之后在调用getClass()方法。 3、Class.forName(String className)：动态加载类第三种则是调用Class类中的forName方法，将字节码文件加载进内存，返回Class对象。 总的来看 结果 但在这三种获取CLass类方式中，我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 获取成员变量Field 获取成员方法Method 获取构造函数 利用反射创建类对象（重点）在前面我们获取了Class对象，之后展示了一系列获取成员变量、成员方法和成员函数的方式后，我们现在可以通过反射来生成实例化对象，一般我们使用Class对象的newInstance()方法来进行创建类对象。 使用的方式也特别简单，只需要通过forname方法获取到的class对象中进行newInstance方法创建即可。 利用反射机制创建类并执行方法"}]